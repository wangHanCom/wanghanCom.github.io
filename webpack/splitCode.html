<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>代码分割 | 汪涵的博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link>
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.98136e72.css" as="style"><link rel="preload" href="/assets/js/app.df490d21.js" as="script"><link rel="preload" href="/assets/js/2.9235f093.js" as="script"><link rel="preload" href="/assets/js/35.34cb4c23.js" as="script"><link rel="prefetch" href="/assets/js/10.92f448a7.js"><link rel="prefetch" href="/assets/js/11.d81451ab.js"><link rel="prefetch" href="/assets/js/12.fe657e2d.js"><link rel="prefetch" href="/assets/js/13.673f55af.js"><link rel="prefetch" href="/assets/js/14.33419792.js"><link rel="prefetch" href="/assets/js/15.ab408685.js"><link rel="prefetch" href="/assets/js/16.41231623.js"><link rel="prefetch" href="/assets/js/17.f98cb10c.js"><link rel="prefetch" href="/assets/js/18.dc28497a.js"><link rel="prefetch" href="/assets/js/19.3bd23e42.js"><link rel="prefetch" href="/assets/js/20.48e0bcc4.js"><link rel="prefetch" href="/assets/js/21.4ca137be.js"><link rel="prefetch" href="/assets/js/22.fe35d04c.js"><link rel="prefetch" href="/assets/js/23.e2151993.js"><link rel="prefetch" href="/assets/js/24.42cdd1be.js"><link rel="prefetch" href="/assets/js/25.2ef590fe.js"><link rel="prefetch" href="/assets/js/26.88fd7535.js"><link rel="prefetch" href="/assets/js/27.aefa961a.js"><link rel="prefetch" href="/assets/js/28.5b4073a9.js"><link rel="prefetch" href="/assets/js/29.4c27b4b2.js"><link rel="prefetch" href="/assets/js/3.74014b60.js"><link rel="prefetch" href="/assets/js/30.f97becd7.js"><link rel="prefetch" href="/assets/js/31.92fc7f70.js"><link rel="prefetch" href="/assets/js/32.d7c4f275.js"><link rel="prefetch" href="/assets/js/33.8d2027ca.js"><link rel="prefetch" href="/assets/js/34.adb9aee5.js"><link rel="prefetch" href="/assets/js/4.ddf5fb83.js"><link rel="prefetch" href="/assets/js/5.2f6ceb2d.js"><link rel="prefetch" href="/assets/js/6.acebe267.js"><link rel="prefetch" href="/assets/js/7.4f5a488b.js"><link rel="prefetch" href="/assets/js/8.d3b85309.js"><link rel="prefetch" href="/assets/js/9.395837cf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98136e72.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">汪涵的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>webpack</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/webpack/devServer.html" class="sidebar-link">devServer</a></li><li><a href="/webpack/import.html" class="sidebar-link">webpack全局引入的问题</a></li><li><a href="/webpack/loader.html" class="sidebar-link">Loader</a></li><li><a href="/webpack/package.html" class="sidebar-link">webpack 基础</a></li><li><a href="/webpack/splitCode.html" aria-current="page" class="active sidebar-link">代码分割</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/webpack/splitCode.html#代码分割的做法" class="sidebar-link">代码分割的做法</a></li><li class="sidebar-sub-header"><a href="/webpack/splitCode.html#静态分割" class="sidebar-link">静态分割</a></li><li class="sidebar-sub-header"><a href="/webpack/splitCode.html#动态分割" class="sidebar-link">动态分割</a></li><li class="sidebar-sub-header"><a href="/webpack/splitCode.html#魔术注释" class="sidebar-link">魔术注释</a></li><li class="sidebar-sub-header"><a href="/webpack/splitCode.html#实战" class="sidebar-link">实战</a></li><li class="sidebar-sub-header"><a href="/webpack/splitCode.html#企业后台打包构建相关" class="sidebar-link">企业后台打包构建相关</a></li></ul></li><li><a href="/webpack/project.html" class="sidebar-link">工程化</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="代码分割"><a href="#代码分割" class="header-anchor">#</a> 代码分割</h1> <h2 id="代码分割的做法"><a href="#代码分割的做法" class="header-anchor">#</a> 代码分割的做法</h2> <p>两种：</p> <ul><li>分离业务代码和第三方库（ vendor ）</li> <li>按需加载（利用 import() 语法）</li></ul> <p>之所以把业务代码和第三方库代码分离出来，是因为需求是源源不断的，因此业务代码更新频率大，==相反第三方库代码更新迭代相对较慢且可以锁版本，所以可以充分利用浏览器的缓存来加载这些第三方库。==</p> <p>而按需加载的适用场景，比如说「==访问某个路由的时候再去加载对应的组件==」，用户不一定会访问所有的路由，所以没必要把所有路由对应的组件都先在开始的加载完；更典型的例子是「某些用户他们的权限只能访问某些页面」，所以没必要把他们没权限访问的页面的代码也加载。</p> <h2 id="静态分割"><a href="#静态分割" class="header-anchor">#</a> 静态分割</h2> <p>静态代码分割是指：在代码中明确声明需要异步加载的代码。</p> <div class="language- extra-class"><pre class="language-text"><code>import Listener from './listeners.js'
const getModal = () =&gt; import('./src/modal.js') Listener.on('didSomethingToWarrentModalBeingLoaded', () =&gt; {  // Async fetching modal code from a separate chunk  getModal().then((module) =&gt; {    const modalTarget = document.getElementById('Modal')    module.initModal(modalTarget)  })})
const getModal = () =&gt; import('./src/modal.js') 

</code></pre></div><p>每当你调用一个声明了异步加载代码的变量时，它总是返回一个 Promise 对象。</p> <p>⚠️ 注意：==在 Vue 中，可以直接使用 import() 关键字做到这一点==，而在 React 中，你需要使用 react-loadable 去完成同样的事。</p> <p>使用场景</p> <ol><li><strong>你正在使用一个非常大的库或框架</strong>：如果在页面初始化时你不需要使用它，就不要在页面初载时加载它；</li> <li><strong>任何临时的资源</strong>：指不在页面初始化时被使用，被使用后又会立即被销毁的资源，例如模态框，对话框，tooltip 等（任何一开始不显示在页面上的东西都可以有条件的加载）；</li> <li><strong>路由</strong>：既然用户不会一下子看到所有页面，那么只把当前页面相关资源给用户就是个明智的做法；</li></ol> <h2 id="动态分割"><a href="#动态分割" class="header-anchor">#</a> 动态分割</h2> <p>在代码调用时根据当前的状态，「动态地」异步加载对应的代码块。</p> <div class="language- extra-class"><pre class="language-text"><code>const getTheme = (themeName) =&gt; import(`./src/themes/${themeName}`)

</code></pre></div><p>Webpack 会在构建时==将你声明的目录下的所有可能分离的代码都抽象为一个文件==（这被称为 contextModule 模块），因此无论你最终声明了调用哪个文件，==本质上就和静态代码分割一样，在请求一个早已准备好的，静态的文件==。</p> <p>使用场景</p> <ol><li>A/B Test：你不需要在代码中引入不需要的 UI 代码；</li> <li>加载主题：根据用户的设置，动态加载相应的主题；</li> <li>为了方便：本质上，你可以用静态代码分割代替「动态」代码分割，但是后者比前者拥有更少的代码量；（少指代码数上的少）</li> <li>企业后台lang的打包</li></ol> <h2 id="魔术注释"><a href="#魔术注释" class="header-anchor">#</a> 魔术注释</h2> <p>魔术注释是由 Webpack 提供的，可以为代码分割服务的一种技术。==通过在 import 关键字后的括号中使用指定注释，我们可以对代码分割后的 chunk 有更多的控制权==</p> <div class="language- extra-class"><pre class="language-text"><code>// index.js
import (
  /* webpackChunkName: “my-chunk-name” */
  './footer'
)
</code></pre></div><p>同时，也要在 webpack.config.js 中做一些改动：</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
{
  output: {
    filename: “bundle.js”,
    chunkFilename: “[name].lazy-chunk.js” //可以对分离出的 chunk 进行命名
  }
}
</code></pre></div><h3 id="webpack-modes"><a href="#webpack-modes" class="header-anchor">#</a> Webpack Modes</h3> <p>==webpackMode 的默认值为 lazy 它会使所有异步模块都会被单独抽离成单一的 chunk==，若设置该值为 lazy-once，Webpack 就会将所有带有标记的异步加载模块放在同一个 chunk 中。</p> <div class="language- extra-class"><pre class="language-text"><code>import (
  /* webpackChunkName: “my-chunk-name” */
  /* webpackMode: lazy */
  './someModule'
)
</code></pre></div><h3 id="prefetch-or-preload"><a href="#prefetch-or-preload" class="header-anchor">#</a> Prefetch or Preload</h3> <p>通过添加 webpackPrefetch 魔术注释，Webpack 令我们可以使用与 <code>&lt;link rel=“prefetch”&gt;</code>相同的特性。让浏览器会在 Idle 状态时预先帮我们加载所需的资源，善用这个技术可以使我们的应用交互变得更加流畅。</p> <div class="language- extra-class"><pre class="language-text"><code>import(
  /* webpackPrefetch: true */
  './someModule'
)
</code></pre></div><h2 id="实战"><a href="#实战" class="header-anchor">#</a> 实战</h2> <p>第一次打包的情况：</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
module.exports = {
  entry: {
     app: './src/main.js', // entry chunk
  },
}
</code></pre></div><p>当前只有一个 <code>chunk</code>也就是<code>app.js</code>，他是一个 <code>entry chunk</code> 。app.js 包含了我们的第三方库 <code>vue</code> 和 <code>axios</code> ，以及我们的业务代码 src 。</p> <h3 id="分离-vendor"><a href="#分离-vendor" class="header-anchor">#</a> 分离 Vendor</h3> <p>加一个 entry</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
module.exports = {
  entry: {
    app: './src/main.js',
    vendor: ['vue', 'axios'],//本次增加的
  },
}
</code></pre></div><p>虽然 vendor.js 这个 entry chunk 包含了我们想要的 vue 和 axios，但是app.js 中也有 vue 和 axios。
原因：
每个 entry 都包含了他自己的依赖，这样他才能作为一个入口，独立地跑起来。</p> <h3 id="提取公共模块commonschunkplugin"><a href="#提取公共模块commonschunkplugin" class="header-anchor">#</a> 提取公共模块CommonsChunkPlugin</h3> <p>webpack v4 legato中已删除CommonsChunkPlugin。要了解如何在最新版本中处理块，请查看<a href="https://webpack.js.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener noreferrer">SplitChunksPlugi<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>增加这一行，找到依赖2次及以上的模块，然后移到 vendor 这个 chunk 里面。</p> <div class="language- extra-class"><pre class="language-text"><code>//webpack.config.js
new webpack.optimize.CommonsChunkPlugin({
  name: 'vendor',
}),
</code></pre></div><p>但是！随着业务的增长，我们依赖的第三方库代码很可能会越来越多，这时候我们的 webpack.config.js 就变成这样了：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  entry: {
    app: './src/main.js',
    vendor: [
      'vue',
      'axio',
      'vue-router',
      'vuex',
      'element-ui',
      // 很长很长
    ],
  },
}
</code></pre></div><p>vendor entry 会变成很长很长，更糟糕的是，我们每次引入了新的第三方库，都需要在 vendor 手动增加对应的包名。</p> <h3 id="自动化分离-vendor"><a href="#自动化分离-vendor" class="header-anchor">#</a> 自动化分离 vendor</h3> <p>看见某些模块是来自 node_modules 目录的，并且名字是 .js 结尾的话，把他们都移到 vendor chunk 里去，如果 vendor chunk 不存在的话，就创建一个新的。</p> <div class="language- extra-class"><pre class="language-text"><code>entry: {
  // vendor: ['vue', 'axios'] // 删掉!
},

new webpack.optimize.CommonsChunkPlugin({
  name: 'vendor',
  minChunks: ({ resource }) =&gt; (
    resource &amp;&amp;
    resource.indexOf('node_modules') &gt;= 0 &amp;&amp;
    resource.match(/\.js$/)
  ),
}),
</code></pre></div><p>以下配置就能从网页 A 和网页 B 中抽离出公共部分，放到 common 中。</p> <div class="language- extra-class"><pre class="language-text"><code>const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');

new CommonsChunkPlugin({
  // 从哪些 Chunk 中提取
  chunks: ['a', 'b'],
  // 提取出的公共部分形成一个新的 Chunk，这个新 Chunk 的名称
  name: 'common'
})
</code></pre></div><p>通过以上配置输出的 common Chunk 中会包含所有页面都依赖的基础运行库 react、react-dom，为了把基础运行库从 common 中抽离到 base 中去，还需要做一些处理。</p> <p>首先需要先配置一个 Chunk，这个 Chunk 中只依赖所有页面都依赖的基础库以及所有页面都使用的样式，为此需要在项目中写一个文件 base.js 来描述 base Chunk 所依赖的模块，文件内容如下：</p> <div class="language- extra-class"><pre class="language-text"><code>//base.js
// 所有页面都依赖的基础库
import 'react';
import 'react-dom';
// 所有页面都使用的样式
import './base.css';
</code></pre></div><p>接着再修改 Webpack 配置，在 entry 中加入 base，相关修改如下：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  entry: {
    base: './base.js'
  },
};
</code></pre></div><p>以上就完成了对新 Chunk base 的配置。</p> <p>为了从 common 中提取出 base 也包含的部分，还需要配置一个 CommonsChunkPlugin，相关代码如下</p> <div class="language- extra-class"><pre class="language-text"><code>new CommonsChunkPlugin({
  // 从 common 和 base 两个现成的 Chunk 中提取公共的部分
  chunks: ['common', 'base'],
  // 把公共的部分放到 base 中
  name: 'base'
})
</code></pre></div><p>由于 common 和 base 公共的部分就是 base 目前已经包含的部分，所以==这样配置后 common 将会变小，而 base 将保持不变。==
以上都配置好后重新执行构建，你将会得到四个文件，它们分别是：</p> <ul><li>base.js：所有网页都依赖的基础库组成的代码；</li> <li>common.js：网页A、B都需要的，但又不在 base.js 文件中出现过的代码；</li> <li>a.js：网页 A 单独需要的代码；</li> <li>b.js：网页 B 单独需要的代码。</li></ul> <p>以上方法可能会出现 common.js 中没有代码的情况，原因是去掉基础运行库外很难再找到所有页面都会用上的模块。 在出现这种情况时，你可以采取以下做法之一：</p> <ul><li>==CommonsChunkPlugin 提供一个选项 minChunks，表示文件要被提取出来时需要在指定的 Chunks 中最小出现最小次数==。 假如 minChunks=2、 chunks=['a','b','c','d']，任何一个文件只要在 ['a','b','c','d'] 中任意两个以上的 Chunk 中都出现过，这个文件就会被提取出来。 你可以根据自己的需求去调整 minChunks 的值，==minChunks 越小越多的文件会被提取到 common.js 中去，但这也会导致部分页面加载的不相关的资源越多==； minChunks 越大越少的文件会被提取到 common.js 中去，但这会导致 common.js 变小、效果变弱。</li> <li>==根据各个页面之间的相关性选取其中的部分页面用 CommonsChunkPlugin 去提取这部分被选出的页面的公共部分，而不是提取所有页面的公共部分，而且这样的操作可以叠加多次。 这样做的效果会很好==，但缺点是配置复杂，你需要根据页面之间的关系去思考如何配置，该方法不通用。</li></ul> <h3 id="按需加载"><a href="#按需加载" class="header-anchor">#</a> 按需加载</h3> <p>如果我们想「按需加载」路由组件的话，修改以下几行。由直接导入改成使用时调用导入。</p> <div class="language- extra-class"><pre class="language-text"><code>// router.js
&lt;!--import Emoji from './pages/Emoji.vue' 旧的写法--&gt;
&lt;!--import Photos from './pages/photos.vue'旧的写法 --&gt;

const Emoji = () =&gt; import(
  /* webpackChunkName: &quot;Emoji&quot; */
  './pages/Emoji.vue')//返回一个

const Photos = () =&gt; import(
  /* webpackChunkName: &quot;Photos&quot; */
  './pages/Photos.vue')
</code></pre></div><p>我们使用了 webpack v2.4 的新功能，可以设置 chunk 的名字；同时别忘了还要改 webpack 配置：</p> <div class="language- extra-class"><pre class="language-text"><code>output: {
  chunkFilename: '[name].chunk.js',
}
</code></pre></div><p>如果你用了 Babel ，就需要装上这个插件：babel plugin syntax dynamic import 来解析 import() 语法。修改 .babelrc ：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;plugins&quot;: [&quot;syntax-dynamic-import&quot;]
}
</code></pre></div><h3 id="自动抽离公共文件"><a href="#自动抽离公共文件" class="header-anchor">#</a> 自动抽离公共文件</h3> <div class="language- extra-class"><pre class="language-text"><code>new webpack.optimize.CommonsChunkPlugin({
  async: 'used-twice',
  minChunks: (module, count) =&gt; (
    count &gt;= 2
  ),
})
</code></pre></div><p>在所有的 async chunk ( Emoji.chunk.js 和 Photos.chunk.js ) 中找到引用 2 次以上的模块，也就是 MagicBtn 咯，那把他挪到 used-twice chunk 中，如果 used-twice 不存在的话，那就创建一个。</p> <p>CommonsChunkPlugin 提供一个选项 minChunks，表示文件要被提取出来时需要在指定的 Chunks 中最小出现最小次数。 假如 minChunks=2、 chunks=['a','b','c','d']，任何一个文件只要在 ['a','b','c','d'] 中任意两个以上的 Chunk 中都出现过，这个文件就会被提取出来。</p> <h2 id="企业后台打包构建相关"><a href="#企业后台打包构建相关" class="header-anchor">#</a> 企业后台打包构建相关</h2> <h3 id="在webpack配置中设置分析的插件"><a href="#在webpack配置中设置分析的插件" class="header-anchor">#</a> 在webpack配置中设置分析的插件</h3> <div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
//开启构建报告
if (process.env.npm_config_report) {
    const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);
    const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
    const smp = new SpeedMeasurePlugin();
    webpackConfig = smp.wrap(webpackConfig);
    webpackConfig.plugins.push(new BundleAnalyzerPlugin());
}
</code></pre></div><p>在命令中开启</p> <div class="language- extra-class"><pre class="language-text"><code>//package.json
{
 &quot;scripts&quot;: {
      &quot;build-report&quot;: &quot;cross-env NODE_ENV=production npm_config_report=true webpack --config build/webpack.config.js&quot;,
 }
 }
</code></pre></div><h3 id="优化"><a href="#优化" class="header-anchor">#</a> 优化</h3> <h4 id="vendor-chunk-体积优化"><a href="#vendor-chunk-体积优化" class="header-anchor">#</a> vendor chunk 体积优化</h4> <div class="language- extra-class"><pre class="language-text"><code>//main.js
import VueCodeMirror from 'vue-codemirror';
import VueECharts from 'echarts'
import 'codemirror/lib/codemirror.css';

Vue.use(VueCodeMirror);
Vue.prototype.$echarts = VueECharts;
</code></pre></div><p>发现main.js中有以上代码。删掉，然后在有需要的代码中再引入。</p> <h4 id="common-chunk-体积优化"><a href="#common-chunk-体积优化" class="header-anchor">#</a> common chunk 体积优化</h4> <p>可以看到 ol库占用了相当多的体积，ol 是openlayer地图库，只有三个 chunk 中有用到，分别是：设备墙地图、geofencing地图、geofencing围栏管理。
所以这个依赖应该仅在这三个功能模块加载时候再下载。</p> <p>另外可以看到其实有一些文件也不适合打包到 common chunk，例如上面显示的一些，devices ，kiosk， geofencing 模块中才用到的复用组件，或者是类似 只有ams与geofencing 两个模块使用到的组件。</p> <div class="language- extra-class"><pre class="language-text"><code>/**
 * 代码分割
 * 文档：https://webpack.docschina.org/plugins/split-chunks-plugin/
 */
splitChunks: {
    cacheGroups: {
        vendors: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'initial',
        },
        // 公共引入的包
        commons: {
            chunks: 'all',
            //至少有3个chunk中引入的代码，才会被构建到 common chunk
            minChunks: 3,
            minSize: 30000,
            name: 'commons',
            //优先级10
            priority: 10,
        },
        //因为openlayer有在3个chunk中引入，但是又不需要打包为公共chunk，所以将openLayer单独打包
        openLayer: {
            test: /[\\/]node_modules[\\/](ol)[\\/]/,
            chunks: 'all',
            name: 'openLayer',
            //优先级20，比上面commons高，所有openlayer的打包会优先于上面，上面打包出的common chunk中就不会打包openlayer
            priority: 20,
        },
    }
}
</code></pre></div><h4 id="moment-js-体积优化"><a href="#moment-js-体积优化" class="header-anchor">#</a> moment.js 体积优化</h4> <div class="language- extra-class"><pre class="language-text"><code>//webpack.config.common.js
//优化moment构建后的体积，仅仅打包需要的语言文件
new webpack.ContextReplacementPlugin(/moment[/\\]locale$/, /ru|zh-cn|zh-tw/),
</code></pre></div><h4 id="语言包按需加载"><a href="#语言包按需加载" class="header-anchor">#</a> 语言包按需加载</h4> <div class="language- extra-class"><pre class="language-text"><code>//i18n.js
loadLangPack();

async function loadLangPack() {
  const fileNames = {
    'en': 'en',
    'zh-cn': 'zh-CN',
    'zh-tw': 'zh-TW',
    'ru': 'ru'
  }

  const airUiLangPacks = {
    'en': airEn,
    'zh-cn': airZH_CN,
    'zh-tw': airZH_TW,
    'ru': airRU_RU
  }

  const langPack = await import( /* webpackChunkName: &quot;lang&quot; */ `./lang/${fileNames[lang]}.json` )

  i18n.setLocaleMessage(lang, { ...langPack, ...airUiLangPacks[lang] })
}
</code></pre></div><p>这样会把语言包文件每个都分别打包，在这里按需加载。
上述处理有一个缺点，执行i18n翻译的代码，不能早于语言包加载完成。否则就会出现没有翻译的情况。好在早于语言包加载就执行翻译的地方不多，很容易就处理了，但是这点今后需要注意。</p> <h4 id="store优化"><a href="#store优化" class="header-anchor">#</a> store优化</h4> <p>目的是将各个功能模块的store文件，打包到功能模块的chunk中。
例如pricing模块：</p> <div class="language- extra-class"><pre class="language-text"><code>//store/pricing.js
const moduleName = 'pricing'

/**
 * 引入的时候再动态注册此模块的 store
 */
!store.hasModule(moduleName) &amp;&amp; store.registerModule(moduleName, {
    //store 的内容
});
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//view/pricing/index.vue
//加载此模块时才会注册store
import 'STORE/pricing';
</code></pre></div><h4 id="代码压缩"><a href="#代码压缩" class="header-anchor">#</a> 代码压缩</h4> <div class="language- extra-class"><pre class="language-text"><code>optimization: {
    minimizer: [
            //压缩css
            new OptimizeCSSAssetsPlugin({
                cssProcessorPluginOptions: {
                    preset: ['default', { discardComments: { removeAll: true } }],
                }
            }),
            //压缩js
            new UglifyJSPlugin({
                cache: true,
                parallel: true,
                sourceMap: false,
                uglifyOptions: {
                    output: {
                        comments: false,
                    },
                    compress: {
                        warnings: false,
                        drop_debugger: isProd,
                        drop_console: isProd
                    }
                },
            })
        ],
}
</code></pre></div><p>参考文章</p> <ul><li><a href="https://zhuanlan.zhihu.com/p/26710831" target="_blank" rel="noopener noreferrer">Webpack 大法之 Code Splitting<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener noreferrer">Code Splitting<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://www.xbhub.com/wiki/webpack/4%E4%BC%98%E5%8C%96/4-11%E6%8F%90%E5%8F%96%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81.html" target="_blank" rel="noopener noreferrer">4-11 提取公共代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener noreferrer">打包分析插件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/webpack/package.html" class="prev">
        webpack 基础
      </a></span> <span class="next"><a href="/webpack/project.html">
        工程化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.df490d21.js" defer></script><script src="/assets/js/2.9235f093.js" defer></script><script src="/assets/js/35.34cb4c23.js" defer></script>
  </body>
</html>
