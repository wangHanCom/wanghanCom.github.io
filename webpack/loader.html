<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Loader | 汪涵的博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link>
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.98136e72.css" as="style"><link rel="preload" href="/assets/js/app.df490d21.js" as="script"><link rel="preload" href="/assets/js/2.9235f093.js" as="script"><link rel="preload" href="/assets/js/32.d7c4f275.js" as="script"><link rel="prefetch" href="/assets/js/10.92f448a7.js"><link rel="prefetch" href="/assets/js/11.d81451ab.js"><link rel="prefetch" href="/assets/js/12.fe657e2d.js"><link rel="prefetch" href="/assets/js/13.673f55af.js"><link rel="prefetch" href="/assets/js/14.33419792.js"><link rel="prefetch" href="/assets/js/15.ab408685.js"><link rel="prefetch" href="/assets/js/16.41231623.js"><link rel="prefetch" href="/assets/js/17.f98cb10c.js"><link rel="prefetch" href="/assets/js/18.dc28497a.js"><link rel="prefetch" href="/assets/js/19.3bd23e42.js"><link rel="prefetch" href="/assets/js/20.48e0bcc4.js"><link rel="prefetch" href="/assets/js/21.4ca137be.js"><link rel="prefetch" href="/assets/js/22.fe35d04c.js"><link rel="prefetch" href="/assets/js/23.e2151993.js"><link rel="prefetch" href="/assets/js/24.42cdd1be.js"><link rel="prefetch" href="/assets/js/25.2ef590fe.js"><link rel="prefetch" href="/assets/js/26.88fd7535.js"><link rel="prefetch" href="/assets/js/27.aefa961a.js"><link rel="prefetch" href="/assets/js/28.5b4073a9.js"><link rel="prefetch" href="/assets/js/29.4c27b4b2.js"><link rel="prefetch" href="/assets/js/3.74014b60.js"><link rel="prefetch" href="/assets/js/30.f97becd7.js"><link rel="prefetch" href="/assets/js/31.92fc7f70.js"><link rel="prefetch" href="/assets/js/33.8d2027ca.js"><link rel="prefetch" href="/assets/js/34.adb9aee5.js"><link rel="prefetch" href="/assets/js/35.34cb4c23.js"><link rel="prefetch" href="/assets/js/4.ddf5fb83.js"><link rel="prefetch" href="/assets/js/5.2f6ceb2d.js"><link rel="prefetch" href="/assets/js/6.acebe267.js"><link rel="prefetch" href="/assets/js/7.4f5a488b.js"><link rel="prefetch" href="/assets/js/8.d3b85309.js"><link rel="prefetch" href="/assets/js/9.395837cf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98136e72.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">汪涵的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>webpack</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/webpack/devServer.html" class="sidebar-link">devServer</a></li><li><a href="/webpack/import.html" class="sidebar-link">webpack全局引入的问题</a></li><li><a href="/webpack/loader.html" aria-current="page" class="active sidebar-link">Loader</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/webpack/loader.html#配置和使用" class="sidebar-link">配置和使用</a></li><li class="sidebar-sub-header"><a href="/webpack/loader.html#loader-类型" class="sidebar-link">Loader 类型</a></li><li class="sidebar-sub-header"><a href="/webpack/loader.html#vue-loader" class="sidebar-link">vue-loader</a></li><li class="sidebar-sub-header"><a href="/webpack/loader.html#style-loader" class="sidebar-link">style-loader</a></li></ul></li><li><a href="/webpack/package.html" class="sidebar-link">webpack 基础</a></li><li><a href="/webpack/splitCode.html" class="sidebar-link">代码分割</a></li><li><a href="/webpack/project.html" class="sidebar-link">工程化</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="loader"><a href="#loader" class="header-anchor">#</a> Loader</h1> <p>Webpack 原生不支持解析 CSS 文件。要支持非 JavaScript 类型的文件，需要使用 Webpack 的 Loader 机制。</p> <h2 id="配置和使用"><a href="#配置和使用" class="header-anchor">#</a> 配置和使用</h2> <h3 id="config中配置"><a href="#config中配置" class="header-anchor">#</a> config中配置</h3> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  // JavaScript 执行入口文件
  entry: './main.js',
  output: {
  //....
  },
  module: {
    rules: [
      {
        // 用正则去匹配要用该 loader 转换的 CSS 文件
        test: /\.css$/,
        use: [
            'style-loader', 
              {
                loader:'css-loader',
                options:{
                  minimize:true,//开启压缩
                }
              }
        ],
      }
    ]
  }
};
</code></pre></div><p>配置里的 module.rules 数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。 如上配置告诉 Webpack 在遇到以 .css 结尾的文件时先使用 css-loader 读取 CSS 文件，再交给 style-loader 把 CSS 内容注入到 JavaScript 里。</p> <ul><li>Loader 的执行顺序是==由后到前==的。</li> <li>每一个 Loader 都可以通过<code>URL querystring</code>的方式传入参数，例如 <code>css-loader?minimize</code>中的 <code>minimize</code> 告诉<code>css-loader</code>要开启 CSS 压缩。</li></ul> <p>Webpack 构建前要先安装新引入的 Loader</p> <div class="language- extra-class"><pre class="language-text"><code>npm i -D style-loader css-loader
</code></pre></div><p>安装成功后重新执行构建时，你会发现 bundle.js 文件被更新了，==里面注入了在 main.css 中写的 CSS，而不是会额外生成一个 CSS 文件。CSS 被写在了 JavaScript 里。== style-loader 它的工作原理大概是把 CSS 内容用 JavaScript 里的字符串存储起来， 在网页执行 JavaScript 时==通过 DOM 操作动态地往 HTML head 标签里插入 HTML style 标签==。</p> <h3 id="内联写法"><a href="#内联写法" class="header-anchor">#</a> 内联写法</h3> <p>可以在 import 等语句里指定 Loader，使用 ! 来将 Loader分开：</p> <div class="language- extra-class"><pre class="language-text"><code>require('style-loader!css-loader?minimize!./main.css');
</code></pre></div><p>这样就能指定对<code>./main.css</code>这个文件先采用 <code>css-loader</code>在采用 <code>style-loader</code>转换。</p> <h2 id="loader-类型"><a href="#loader-类型" class="header-anchor">#</a> Loader 类型</h2> <h3 id="同步-loader"><a href="#同步-loader" class="header-anchor">#</a> 同步 Loader</h3> <div class="language- extra-class"><pre class="language-text"><code>module.exports = function(source) {
  const result = someSyncOperation(source); // 同步逻辑
  return result;
}
</code></pre></div><p><code>Loader</code>都是同步的，通过 <code>return</code>或者<code>this.callback</code> 来同步地返回<code>source</code>转换后的结果。</p> <h3 id="异步loader"><a href="#异步loader" class="header-anchor">#</a> 异步Loader</h3> <p>有的时候，我们需要在 Loader 里做一些异步的事情，比如说需要发送网络请求。</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = function(source) {
  // 告诉 webpack 这次转换是异步的
  const callback = this.async();
  // 异步逻辑
  someAsyncOperation(content, function(err, result) {
    if (err) return callback(err);
    // 通过 callback 来返回异步处理的结果
    callback(null, result, map, meta);
  });
};
</code></pre></div><h3 id="pitching-loader"><a href="#pitching-loader" class="header-anchor">#</a> Pitching Loader</h3> <p><code>Pitching Loader</code>是一个比较重要的概念，之前在 <code>style-loader</code> 里有提到过。</p> <div class="language- extra-class"><pre class="language-text"><code>{
  test: /\.js$/,
  use: [
    { loader: 'aa-loader' },
    { loader: 'bb-loader' },
    { loader: 'cc-loader' },
  ]
}
</code></pre></div><p>Loader 总是从右到左被调用。上面配置的 Loader，就会按照以下顺序执行：</p> <div class="language- extra-class"><pre class="language-text"><code>//  cc-loader -&gt; bb-loader -&gt; aa-loader
</code></pre></div><p>每个<code>Loader</code> 都支持一个 <code>pitch</code>属性，通过<code>module.exports.pitch</code> 声明。如果该 <code>Loader</code>声明了<code>pitch</code>，则该方法会优先于<code>Loader</code> 的实际方法先执行。==先从左向右执行一次每个 Loader 的 pitch 方法==，再按照从右向左的顺序执行其实际方法。</p> <h3 id="raw-loader"><a href="#raw-loader" class="header-anchor">#</a> Raw Loader</h3> <div class="language- extra-class"><pre class="language-text"><code>export const raw = true;
</code></pre></div><p>默认情况下，webpack 会把文件进行 UTF-8 编码，然后传给 Loader。==通过设置 raw，Loader 就可以接受到原始的 Buffer 数据==。</p> <h2 id="vue-loader"><a href="#vue-loader" class="header-anchor">#</a> vue-loader</h2> <p>「vue-loader」 是一个 webpack 的 loader，它允许你以一种名为单文件组件的格式撰写 Vue 组件。</p> <h3 id="安装与使用"><a href="#安装与使用" class="header-anchor">#</a> 安装与使用</h3> <div class="language- extra-class"><pre class="language-text"><code> Vue 框架运行需要的库
npm i -S vue
# 构建所需的依赖
npm i -D vue-loader css-loader vue-template-compiler
</code></pre></div><p>在这些依赖中，它们的作用分别是：</p> <ul><li>vue-loader：==解析和转换 .vue 文件==，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版。 template，==再分别把它们交给对应的 Loader 去处理==。</li> <li>css-loader：加载由 vue-loader 提取出的 CSS 代码。</li> <li>vue-template-compiler：把 vue-loader 提取出的 HTML 模版编译成对应的可执行的 JavaScript 代码，这和 React 中的 JSX 语法被编译成 JavaScript 代码类似。预先编译好 HTML 模版相对于在浏览器中再去编译 HTML 模版的好处在于性能更好。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
const VueLoaderPlugin = require('vue-loader/lib/plugin')

module.exports = {
  mode: 'development',
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },
      // 它会应用到普通的 `.js` 文件
      // 以及 `.vue` 文件中的 `&lt;script&gt;` 块
      {
        test: /\.js$/,
        loader: 'babel-loader'
      },
      // 它会应用到普通的 `.css` 文件
      // 以及 `.vue` 文件中的 `&lt;style&gt;` 块
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    // 请确保引入这个插件来施展魔法
    new VueLoaderPlugin()
  ]
}

</code></pre></div><p>一个标准的 Vue 组件可以分为三部分：</p> <p>1、template: 模板
2、script: 脚本
3、stype: 样式</p> <p>Vue 组件里的<code>&lt;template&gt;</code>部分解析到<code>&lt;body&gt;</code> 下，css 部分解析成 <code>&lt;style&gt;</code>标签，<code>&lt;script&gt;</code> 部分则解析到 js 文件里。</p> <h3 id="源码解析之整体分析"><a href="#源码解析之整体分析" class="header-anchor">#</a> 源码解析之整体分析</h3> <p>入口看起，从上往下看：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = function (source) {}
//vue-loader 接收一个 source 字符串，值是 vue 文件的内容。
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>const stringifyRequest = r =&gt; loaderUtils.stringifyRequest(loaderContext, r)
//loaderUtils.stringifyRequest 作用是将绝对路径转换成相对路径。
</code></pre></div><p>接下来有一大串的声明语句，我们暂且先不看，我们先看最简单的情况。</p> <div class="language- extra-class"><pre class="language-text"><code>const { parse } = require('@vue/component-compiler-utils') //导入parse方法

const descriptor = parse({
  source,
  compiler: options.compiler || loadTemplateCompiler(loaderContext),
  filename,
  sourceRoot,
  needMap: sourceMap
})
</code></pre></div><p>parse 方法是来自于 component-compiler-utils，代码简略一下是这样：</p> <div class="language- extra-class"><pre class="language-text"><code>// component-compiler-utils parse
function parse(options) {
  const { source, filename = '', compiler, compilerParseOptions = { pad: 'line' }, sourceRoot = '', needMap = true } = options;
  // ...
  output = compiler.parseComponent(source, compilerParseOptions);
  // ...
  return output;
}
</code></pre></div><p>这里还不是真正 parse 的地方，实际上是调用了 compiler.parseComponent 方法，默认情况下 compiler 指的是 vue-template-compiler。</p> <div class="language- extra-class"><pre class="language-text"><code>// vue-template-compiler parseComponent
function parseComponent (
  content,
  options
) {
  var sfc = {
    template: null,
    script: null,
    styles: [],
    customBlocks: [],
    errors: []
  };
  // ...
  function start() {}
  function end() {}
  parseHTML(content, {
    warn: warn,
    start: start,
    end: end,
    outputSourceRange: options.outputSourceRange
  });
  return sfc;
}
</code></pre></div><p>parseComponent 应该是调用了 parseHTML 方法，并且传入了两个方法：start 和 end，最终返回 sfc。</p> <p>我们可以猜测 start 和 end 这两个方法应该是会根据不同的规则去修改 sfc，我们看一下 sfc 即 vue-loader 中 descriptor 是怎么样的：</p> <div class="language- extra-class"><pre class="language-text"><code>// vue-loader descriptor
{
  customBlocks: [],
  errors: [],
  template: {
    attrs: {},
    content: &quot;\n&lt;div id=&quot;app&quot;&gt;\n  &lt;div class=&quot;title&quot;&gt;{{msg}}&lt;/div&gt;\n&lt;/div&gt;\n&quot;,
    type: &quot;template&quot;
  },
  script: {
    attrs: {},
    content: &quot;... export default {} ...&quot;,
    type: &quot;script&quot;
  },
  style: [{
    attrs: {
      lang: &quot;scss&quot;
    },
    content: &quot;... #app {} ...&quot;,
    type: &quot;style&quot;,
    lang: &quot;scss&quot;
  }],
}
</code></pre></div><h3 id="vue-loader-如何处理不同-type"><a href="#vue-loader-如何处理不同-type" class="header-anchor">#</a> vue-loader 如何处理不同 type</h3> <p>最终作用是针对不同的 type 分别构造一个 import 字符串：</p> <div class="language- extra-class"><pre class="language-text"><code>templateImport = &quot;import { render, staticRenderFns } from './App.vue?vue&amp;type=template&amp;id=7ba5bd90&amp;'&quot;;

scriptImport = &quot;import script from './App.vue?vue&amp;type=script&amp;lang=js&amp;'
                export * from './App.vue?vue&amp;type=script&amp;lang=js&amp;'&quot;;

stylesCode = &quot;import style0 from './App.vue?vue&amp;type=style&amp;index=0&amp;lang=scss&amp;'&quot;;
</code></pre></div><p>这三个 import 语句有什么用呢， vue-loader 是这样做的：</p> <div class="language- extra-class"><pre class="language-text"><code>let code = `
${templateImport}
${scriptImport}
${stylesCode}`.trim() + `\n`
code += `\nexport default component.exports`
return code
</code></pre></div><p>此时， code 是这样的：</p> <div class="language- extra-class"><pre class="language-text"><code>code = &quot;
import { render, staticRenderFns } from './App.vue?vue&amp;type=template&amp;id=7ba5bd90&amp;'
import script from './App.vue?vue&amp;type=script&amp;lang=js&amp;'
export * from './App.vue?vue&amp;type=script&amp;lang=js&amp;'
import style0 from './App.vue?vue&amp;type=style&amp;index=0&amp;lang=scss&amp;'

// 省略 ...
export default component.exports&quot;
</code></pre></div><p>code 里有三次的 import，import 的文件都是 App.vue，相当于又加载了一次触发这次 vue-loader 的那个 vue 文件。不同的是，==这次加载是「带参」的，分别对应着 template / script / style 三种 type 的处理。==</p> <p>总结：
webpack 在加载 vue 文件时，会==调用 vue-loader 来处理 vue 文件，之后 return 一段可执行的 js== 代码，其中会根据不同 type 分别 import 一次当前 vue 文件，并且==将参数传递进去，这里的多次 import 也会被 vue-loader 拦截，然后在 vue-loader 内部根据不同参数进行处理==（比如调用 style-loader）。</p> <h2 id="style-loader"><a href="#style-loader" class="header-anchor">#</a> style-loader</h2> <h3 id="作用"><a href="#作用" class="header-anchor">#</a> 作用</h3> <p>style-loader 的功能就一个，在 DOM 里插入一个 <code>&lt;style&gt;</code>标签，并且将 CSS 写入这个标签内。</p> <p>简单来说是这样：</p> <div class="language- extra-class"><pre class="language-text"><code>const style = document.createElement('style'); // 新建一个 style 标签
style.type = 'text/css';
style.appendChild(document.createTextNode(content)) // CSS 写入 style 标签
document.head.appendChild(style); // style 标签插入 head 中
</code></pre></div><h3 id="安装与配置"><a href="#安装与配置" class="header-anchor">#</a> 安装与配置</h3> <div class="language- extra-class"><pre class="language-text"><code>
npm install style-loader --save-dev
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(css)$/,
        use: [
          {
            loader: 'style-loader',
             options: {
                injectType: 'singletonStyleTag',//默认值是styleTag
             },
          },
          { loader: 'css-loader' },
        ],
      },
    ],
  },
};
</code></pre></div><h4 id="singletonstyletag"><a href="#singletonstyletag" class="header-anchor">#</a> singletonStyleTag</h4> <p>==singletonStyleTag==，会按照引入顺序把两个样式文件的内容都被==放到同一个 <code>&lt;style&gt;</code>标签里==。</p> <h4 id="linktag"><a href="#linktag" class="header-anchor">#</a> linkTag</h4> <p>当 ==injectType 为 linkTag==，会通过 <link rel="stylesheet" href=""> 的形式将样式插入到 DOM 中，==此时 style-loader 接收到的数据应该是样式文件的地址==，所以搭配的 loader 应该是 ==file-loader== 而不是 css-loader。</p> <p>值为<code>linkTag</code>打包前</p> <div class="language- extra-class"><pre class="language-text"><code>// js
const globalStyle = require('./assets/style/global.css');
const indexStyle = require('./assets/style/index.css');
</code></pre></div><p>打包后</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;head&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;f2742027f8729dc63bfd46029a8d0d6a.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;34cd6c668a7a596c4bedad32a39832cf.css&quot;&gt;
&lt;/head&gt;
</code></pre></div><h4 id="lazystyletag-lazysingletonstyletag"><a href="#lazystyletag-lazysingletonstyletag" class="header-anchor">#</a> lazyStyleTag, lazySingletonStyleTag</h4> <p>这两种类型的 injectType 区别在于它们是延迟加载的：</p> <div class="language- extra-class"><pre class="language-text"><code>// 打包前的js
const globalStyle = require('./assets/style/global.css');
const indexStyle = require('./assets/style/index.css');
</code></pre></div><p>==如果像上面一样导入了样式文件，样式是不会插入到 DOM 中的==，需要手动使用 globalStyle.use() 来延迟加载 global.css 这个样式文件。</p> <div class="language- extra-class"><pre class="language-text"><code>   globalStyle.use();
</code></pre></div><h3 id="源码分析"><a href="#源码分析" class="header-anchor">#</a> 源码分析</h3> <p>style-loader 主要可以分为：</p> <ul><li>打包阶段</li> <li>runtime 阶段</li></ul> <h4 id="打包阶段"><a href="#打包阶段" class="header-anchor">#</a> 打包阶段</h4> <p>引入依赖部分</p> <div class="language- extra-class"><pre class="language-text"><code>//定义了一个 _interopRequireDefault 方法，传入的是一个 require()。
var _path = _interopRequireDefault(require(&quot;path&quot;));
var _loaderUtils = _interopRequireDefault(require(&quot;loader-utils&quot;));
var _schemaUtils = _interopRequireDefault(require(&quot;schema-utils&quot;));
var _options = _interopRequireDefault(require(&quot;./options.json&quot;));
//如果引入的是 es6 模块，直接返回，如果是 commonjs 模块，则将引入的内容放在一个对象的 default 属性上，然后返回这个对象。
function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>module.exports = () =&gt; {};
module.exports.pitch = function loader(request) {}
</code></pre></div><p>style-loader 的导出方式和普通的 loader 不太一样，默认导出一个空方法，通过 pitch 导出的。
默认的 loader 都是从右向左像管道一样执行，而 ==pitch 是从左到右执行的==。</p> <p>这样做的原因：
style-loader 的作用是将 CSS 代码插入到 DOM 中，如果按照顺序从 css-loader 接收到一个 js 字符串的话，就无法获取到真实的 CSS 样式了。所以==正确的做法是先执行 style-loader，在它里面去执行 css-loader ，拿到经过处理的 CSS 内容，再插入到 DOM 中==。</p> <p><code>loader</code>的内容：</p> <div class="language- extra-class"><pre class="language-text"><code>// 获取 webpack 配置里的 options
const options = _loaderUtils.default.getOptions(this) || {};
// 校验 options
(0, _schemaUtils.default)(_options.default, options, {
  name: 'Style Loader',
  baseDataPath: 'options'
});

// style 标签插入的位置，默认是 head
const insert = typeof options.insert === 'undefined' ? '&quot;head&quot;' : typeof options.insert === 'string' ? JSON.stringify(options.insert) : options.insert.toString();
// 设置以哪种方式插入 DOM 中
// 详情见这个：https://github.com/webpack-contrib/style-loader#injecttype
const injectType = options.injectType || 'styleTag';

//根据不同的 injectType 会 return 不同的 js 代码，在 runtime 的时候执行。
switch (injectType) {
  case 'linkTag': {}
  case 'lazyStyleTag':
  case 'lazySingletonStyleTag': {}
  case 'styleTag':
  case 'singletonStyleTag':
  default: {}
}
</code></pre></div><p>根据不同的 injectType 会 return 不同的 js 代码，在 runtime 的时候执行。</p> <p>看看默认情况：</p> <div class="language- extra-class"><pre class="language-text"><code>return `var content = require(${_loaderUtils.default.stringifyRequest(this, `!!${request}`)});

if (typeof content === 'string') {
  content = [[module.id, content, '']];
}

var options = ${JSON.stringify(options)}

options.insert = ${insert};
options.singleton = ${isSingleton};

var update = require(${_loaderUtils.default.stringifyRequest(this, `!${_path.default.join(__dirname, 'runtime/injectStylesIntoStyleTag.js')}`)})(content, options);

if (content.locals) {
  module.exports = content.locals;
}
${hmrCode}`;
</code></pre></div><p>_loaderUtils.default.stringifyRequest(this, <code>!!${request}</code>) 这个方法的作用是将绝对路径转换成相对路径。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>import css from './asset/style/global.css';
// 此时传递给 style-loader 的 request 会是
request = '/test-loader/node_modules/css-loader/dist/cjs.js!/test-loader/assets/style/global.css';
// 转换
_loaderUtils.default.stringifyRequest(this, `!!${request}`);
// result: &quot;!!../../node_modules/css-loader/dist/cjs.js!./global.css&quot;
</code></pre></div><p>所以 content 的实际内容就是：</p> <div class="language- extra-class"><pre class="language-text"><code>var content = require(&quot;!!../../node_modules/css-loader/dist/cjs.js!./global.css&quot;);
</code></pre></div><p>也就是在这里才去调用 css-loader 来处理样式文件。</p> <p>!! 模块前面的两个感叹号的作用是禁用 loader 的配置的，如果不禁用的话会出现无限递归调用的情况。</p> <p>同样的，update 的实际内容是：</p> <div class="language- extra-class"><pre class="language-text"><code>./../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js&quot;)(content, options);
</code></pre></div><p>意思也就是调用 <code>injectStylesIntoStyleTage</code>模块来处理经过<code>css-loader</code> 处理过的样式内容<code>content</code>。</p> <p>上述代码都是 <code>style-loader</code> 返回的，真正执行是在<code>runtime</code>阶段。</p> <p>参考链接</p> <ul><li><a href="https://github.com/axuebin/articles/issues/38" target="_blank" rel="noopener noreferrer">前端工程师都得掌握的 webpack Loader<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/NO5jZfoHZbjOwR8qiWnXmw" target="_blank" rel="noopener noreferrer">webpack loader 从上手到理解系列：vue-loader<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/alIKsKkGRU_yyjpeV8i0og" target="_blank" rel="noopener noreferrer">webpack loader 从上手到理解系列：style-loader<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/webpack/import.html" class="prev">
        webpack全局引入的问题
      </a></span> <span class="next"><a href="/webpack/package.html">
        webpack 基础
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.df490d21.js" defer></script><script src="/assets/js/2.9235f093.js" defer></script><script src="/assets/js/32.d7c4f275.js" defer></script>
  </body>
</html>
