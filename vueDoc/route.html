<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>路由 | 汪涵的博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link>
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.98136e72.css" as="style"><link rel="preload" href="/assets/js/app.df490d21.js" as="script"><link rel="preload" href="/assets/js/2.9235f093.js" as="script"><link rel="preload" href="/assets/js/27.aefa961a.js" as="script"><link rel="prefetch" href="/assets/js/10.92f448a7.js"><link rel="prefetch" href="/assets/js/11.d81451ab.js"><link rel="prefetch" href="/assets/js/12.fe657e2d.js"><link rel="prefetch" href="/assets/js/13.673f55af.js"><link rel="prefetch" href="/assets/js/14.33419792.js"><link rel="prefetch" href="/assets/js/15.ab408685.js"><link rel="prefetch" href="/assets/js/16.41231623.js"><link rel="prefetch" href="/assets/js/17.f98cb10c.js"><link rel="prefetch" href="/assets/js/18.dc28497a.js"><link rel="prefetch" href="/assets/js/19.3bd23e42.js"><link rel="prefetch" href="/assets/js/20.48e0bcc4.js"><link rel="prefetch" href="/assets/js/21.4ca137be.js"><link rel="prefetch" href="/assets/js/22.fe35d04c.js"><link rel="prefetch" href="/assets/js/23.e2151993.js"><link rel="prefetch" href="/assets/js/24.42cdd1be.js"><link rel="prefetch" href="/assets/js/25.2ef590fe.js"><link rel="prefetch" href="/assets/js/26.88fd7535.js"><link rel="prefetch" href="/assets/js/28.5b4073a9.js"><link rel="prefetch" href="/assets/js/29.4c27b4b2.js"><link rel="prefetch" href="/assets/js/3.74014b60.js"><link rel="prefetch" href="/assets/js/30.f97becd7.js"><link rel="prefetch" href="/assets/js/31.92fc7f70.js"><link rel="prefetch" href="/assets/js/32.d7c4f275.js"><link rel="prefetch" href="/assets/js/33.8d2027ca.js"><link rel="prefetch" href="/assets/js/34.adb9aee5.js"><link rel="prefetch" href="/assets/js/35.34cb4c23.js"><link rel="prefetch" href="/assets/js/4.ddf5fb83.js"><link rel="prefetch" href="/assets/js/5.2f6ceb2d.js"><link rel="prefetch" href="/assets/js/6.acebe267.js"><link rel="prefetch" href="/assets/js/7.4f5a488b.js"><link rel="prefetch" href="/assets/js/8.d3b85309.js"><link rel="prefetch" href="/assets/js/9.395837cf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98136e72.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">汪涵的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vueDoc/route.html" aria-current="page" class="active sidebar-link">路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vueDoc/route.html#spa" class="sidebar-link">SPA</a></li><li class="sidebar-sub-header"><a href="/vueDoc/route.html#hash实现路由" class="sidebar-link">hash实现路由</a></li><li class="sidebar-sub-header"><a href="/vueDoc/route.html#history-模式" class="sidebar-link">history 模式</a></li></ul></li><li><a href="/vueDoc/vue.html" class="sidebar-link">vue源码</a></li><li><a href="/vueDoc/vueRouter.html" class="sidebar-link">router</a></li><li><a href="/vueDoc/bindData.html" class="sidebar-link">vue双向绑定</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h1> <h2 id="spa"><a href="#spa" class="header-anchor">#</a> SPA</h2> <p>SPA 是 single page web application 的简称，译为单页Web应用。
简单的说 SPA 就是一个WEB项目只有一个 HTML 页面，一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转。
取而代之的是利用 JS 动态的变换 HTML 的内容，从而来模拟多个视图间跳转。</p> <p>但由于 SPA 中用户的交互是通过 JS 改变 HTML 内容来实现的，页面本身的 url 并没有变化，这导致了两个问题：</p> <ol><li>SPA 无法记住用户的操作记录，无论是刷新、前进还是后退，都无法展示用户真实的期望内容。</li> <li>SPA 中虽然由于业务的不同会有多种页面展示形式，但只有一个 url，对 SEO 不友好，不方便搜索引擎进行收录。</li></ol> <p>前端路由就是为了解决上述问题而出现的。</p> <p>对于单页应用的 history 模式而言，url 的改变只能由下面四种方式引起：</p> <ul><li>点击浏览器的前进或后退按钮</li> <li>点击 a 标签（hash模式实现路由）</li> <li>在 JS 代码中触发 history.pushState 函数</li> <li>在 JS 代码中触发 history.replaceState 函数</li></ul> <h2 id="hash实现路由"><a href="#hash实现路由" class="header-anchor">#</a> hash实现路由</h2> <p>这里的 hash 就是指 url 后的 # 号以及后面的字符。比如说 &quot;www.baidu.com/#hashhash&quot; ，其中 &quot;#hashhash&quot; 就是我们期望的 hash 值。
==由于 hash 值的变化不会导致浏览器像服务器发送请求，而且 hash 的改变会触发 hashchange 事件，浏览器的前进后退也能对其进行控制==</p> <div class="language- extra-class"><pre class="language-text"><code>class HashRouter{
    constructor(){
        //用于存储不同hash值对应的回调函数
        this.routers = {};
        window.addEventListener('hashchange',this.load.bind(this),false)
    }
    //用于注册每个视图
    register(hash,callback = function(){}){
        this.routers[hash] = callback;
    }
    //用于注册首页
    registerIndex(callback = function(){}){
        this.routers['index'] = callback;
    }
    //用于处理视图未找到的情况
    registerNotFound(callback = function(){}){
        this.routers['404'] = callback;
    }
    //用于处理异常情况
    registerError(callback = function(){}){
        this.routers['error'] = callback;
    }
    //用于调用不同视图的回调函数
    load(){
        let hash = location.hash.slice(1),
            handler;
        //没有hash 默认为首页
        if(!hash){
            handler = this.routers.index;
        }
        //未找到对应hash值
        else if(!this.routers.hasOwnProperty(hash)){
            handler = this.routers['404'] || function(){};
        }
        else{
            handler = this.routers[hash]
        }
        //执行注册的回调函数
        try{
            handler.apply(this);
        }catch(e){
            console.error(e);
            (this.routers['error'] || function(){}).call(this,e);
        }
    }
}


let router = new HashRouter();
let container = document.getElementById('container');

//注册首页回调函数
router.registerIndex(()=&gt; container.innerHTML = '我是首页');

//注册其他视图回到函数
router.register('/page1',()=&gt; container.innerHTML = '我是page1');
router.register('/page2',()=&gt; container.innerHTML = '我是page2');
router.register('/page3',()=&gt; container.innerHTML = '我是page3');
router.register('/page4',()=&gt; {throw new Error('抛出一个异常')});

//加载视图
router.load();
//注册未找到对应hash值时的回调
router.registerNotFound(()=&gt;container.innerHTML = '页面未找到');
//注册出现异常时的回调
router.registerError((e)=&gt;container.innerHTML = '页面异常，错误消息：&lt;br&gt;' + e.message);

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>&lt;body&gt;
    &lt;div id=&quot;nav&quot;&gt;
        &lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt;
        &lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt;
        &lt;a href=&quot;#/page3&quot;&gt;page3&lt;/a&gt;
    &lt;/div&gt;
    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;/body&gt;

</code></pre></div><ol><li>通过href触发hash值的改变</li> <li>通过hashchange监听hash值的改变</li> <li>hash值改变的时候执行回调，修改当前页面</li> <li>registerNotFound 方法，用于注册 hash 值未找到时的默认回调函数；</li> <li>增加 try/catch 用于捕获异常</li> <li>registerError 方法，用于处理异常</li></ol> <h2 id="history-模式"><a href="#history-模式" class="header-anchor">#</a> history 模式</h2> <p>在 HTML5 的规范中，history 新增了以下几个 API：</p> <div class="language- extra-class"><pre class="language-text"><code>history.pushState();     // 添加新的状态到历史状态栈
history.replaceState();  // 用新的状态代替当前状态
history.state            // 返回当前状态对象

</code></pre></div><p>history.pushState() 和 history.replaceState() 的区别在于：</p> <ul><li>history.pushState() 在保留现有历史记录的同时，将 url 加入到历史记录中。</li> <li>history.replaceState() 会将历史记录中的当前页面历史替换为 url。（区别在后退时跳转不一致）</li></ul> <p>==由于 history.pushState() 和 history.replaceState() 可以改变 url 同时，不会刷新页面==，所以在 HTML5 中的 histroy 具备了实现前端路由的能力。</p> <div class="language- extra-class"><pre class="language-text"><code>class HistoryRouter{
    constructor(){
        //用于存储不同path值对应的回调函数
        this.routers = {};
        this.listenPopState();
        this.listenLink();
    }
    //监听popstate
    listenPopState(){
    //监听 popstate 用于处理前进后退时调用对应的回调函数
        window.addEventListener('popstate',(e)=&gt;{
            let state = e.state || {},
                path = state.path || '';
            this.dealPathHandler(path)
        },false)
    }
    //全局监听A链接
    listenLink(){
    //全局阻止A链接的默认事件，获取A链接的href属性，并调用 history.pushState 方法
        window.addEventListener('click',(e)=&gt;{
            let dom = e.target;
            if(dom.tagName.toUpperCase() === 'A' &amp;&amp; dom.getAttribute('href')){
                e.preventDefault()
                this.assign(dom.getAttribute('href'));
            }
        },false)
    }
    //用于首次进入页面时调用
    load(){
        let path = location.pathname;
        this.dealPathHandler(path)
    }
    //用于注册每个视图
    register(path,callback = function(){}){
        this.routers[path] = callback;
    }
    //用于注册首页
    registerIndex(callback = function(){}){
        this.routers['/'] = callback;
    }
    //用于处理视图未找到的情况
    registerNotFound(callback = function(){}){
        this.routers['404'] = callback;
    }
    //用于处理异常情况
    registerError(callback = function(){}){
        this.routers['error'] = callback;
    }
    //跳转到path
    assign(path){
        history.pushState({path},null,path);
        this.dealPathHandler(path)
    }
    //替换为path
    replace(path){
        history.replaceState({path},null,path);
        this.dealPathHandler(path)
    }
    //通用处理 path 调用回调函数
    dealPathHandler(path){
        let handler;
        //没有对应path
        if(!this.routers.hasOwnProperty(path)){
            handler = this.routers['404'] || function(){};
        }
        //有对应path
        else{
            handler = this.routers[path];
        }
        try{
            handler.call(this)
        }catch(e){
            console.error(e);
            (this.routers['error'] || function(){}).call(this,e);
        }
    }
}


let router = new HistoryRouter();
let container = document.getElementById('container');

//注册首页回调函数
router.registerIndex(() =&gt; container.innerHTML = '我是首页');

//注册其他视图回到函数
router.register('/page1', () =&gt; container.innerHTML = '我是page1');
router.register('/page2', () =&gt; container.innerHTML = '我是page2');
router.register('/page3', () =&gt; container.innerHTML = '我是page3');
router.register('/page4', () =&gt; {
    throw new Error('抛出一个异常')
});

document.getElementById('btn').onclick = () =&gt; router.assign('/page2')


//注册未找到对应path值时的回调
router.registerNotFound(() =&gt; container.innerHTML = '页面未找到');
//注册出现异常时的回调
router.registerError((e) =&gt; container.innerHTML = '页面异常，错误消息：&lt;br&gt;' + e.message);
//加载页面
router.load();

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>&lt;body&gt;
    &lt;div id=&quot;nav&quot;&gt;
        &lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;
        &lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;
        &lt;a href=&quot;/page3&quot;&gt;page3&lt;/a&gt;
        &lt;a href=&quot;/page4&quot;&gt;page4&lt;/a&gt;
        &lt;a href=&quot;/page5&quot;&gt;page5&lt;/a&gt;
        &lt;button id=&quot;btn&quot;&gt;page2&lt;/button&gt;
    &lt;/div&gt;
    &lt;div id=&quot;container&quot;&gt;

    &lt;/div&gt;
&lt;/body&gt;

</code></pre></div><p>history 在修改 url 后，虽然页面并不会刷新，==但我们在手动刷新，或通过 url 直接进入应用的时候，
服务端是无法识别这个 url 的。因为我们是单页应用，只有一个 html 文件，服务端在处理其他路径的 url 的时候，就会出现404的情况==。
所以，如果要应用 history 模式，==需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回单页应用的 html 文件==。</p> <p>hash 模式相比于 history 模式的优点</p> <ul><li>兼容性更好，可以兼容到IE8</li> <li>无需服务端配合处理非单页的url地址</li></ul> <p>hash 模式相比于 history 模式的缺点：</p> <ul><li>看起来更丑。</li> <li>会导致锚点功能失效。</li> <li>相同 hash 值不会触发动作将记录加入到历史栈中，而 pushState 则可以。</li></ul> <p>综上所述，当我们不需要兼容老版本IE浏览器，并且可以控制服务端覆盖所有情况的候选资源时，我们可以愉快的使用 history 模式了。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/networkDoc/urlDesc.html" class="prev">
        输入一个url发生了什么
      </a></span> <span class="next"><a href="/vueDoc/vue.html">
        vue源码
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.df490d21.js" defer></script><script src="/assets/js/2.9235f093.js" defer></script><script src="/assets/js/27.aefa961a.js" defer></script>
  </body>
</html>
