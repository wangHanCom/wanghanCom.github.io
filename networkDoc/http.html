<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>http协议 | 汪涵的博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link>
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.98136e72.css" as="style"><link rel="preload" href="/assets/js/app.df490d21.js" as="script"><link rel="preload" href="/assets/js/2.9235f093.js" as="script"><link rel="preload" href="/assets/js/19.3bd23e42.js" as="script"><link rel="prefetch" href="/assets/js/10.92f448a7.js"><link rel="prefetch" href="/assets/js/11.d81451ab.js"><link rel="prefetch" href="/assets/js/12.fe657e2d.js"><link rel="prefetch" href="/assets/js/13.673f55af.js"><link rel="prefetch" href="/assets/js/14.33419792.js"><link rel="prefetch" href="/assets/js/15.ab408685.js"><link rel="prefetch" href="/assets/js/16.41231623.js"><link rel="prefetch" href="/assets/js/17.f98cb10c.js"><link rel="prefetch" href="/assets/js/18.dc28497a.js"><link rel="prefetch" href="/assets/js/20.48e0bcc4.js"><link rel="prefetch" href="/assets/js/21.4ca137be.js"><link rel="prefetch" href="/assets/js/22.fe35d04c.js"><link rel="prefetch" href="/assets/js/23.e2151993.js"><link rel="prefetch" href="/assets/js/24.42cdd1be.js"><link rel="prefetch" href="/assets/js/25.2ef590fe.js"><link rel="prefetch" href="/assets/js/26.88fd7535.js"><link rel="prefetch" href="/assets/js/27.aefa961a.js"><link rel="prefetch" href="/assets/js/28.5b4073a9.js"><link rel="prefetch" href="/assets/js/29.4c27b4b2.js"><link rel="prefetch" href="/assets/js/3.74014b60.js"><link rel="prefetch" href="/assets/js/30.f97becd7.js"><link rel="prefetch" href="/assets/js/31.92fc7f70.js"><link rel="prefetch" href="/assets/js/32.d7c4f275.js"><link rel="prefetch" href="/assets/js/33.8d2027ca.js"><link rel="prefetch" href="/assets/js/34.adb9aee5.js"><link rel="prefetch" href="/assets/js/35.34cb4c23.js"><link rel="prefetch" href="/assets/js/4.ddf5fb83.js"><link rel="prefetch" href="/assets/js/5.2f6ceb2d.js"><link rel="prefetch" href="/assets/js/6.acebe267.js"><link rel="prefetch" href="/assets/js/7.4f5a488b.js"><link rel="prefetch" href="/assets/js/8.d3b85309.js"><link rel="prefetch" href="/assets/js/9.395837cf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98136e72.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">汪涵的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>计算机网络</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/networkDoc/" aria-current="page" class="sidebar-link">计算机网络</a></li><li><a href="/networkDoc/browserCache.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/networkDoc/dns.html" class="sidebar-link">DNS</a></li><li><a href="/networkDoc/http.html" aria-current="page" class="active sidebar-link">http协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/networkDoc/http.html#http" class="sidebar-link">http</a></li><li class="sidebar-sub-header"><a href="/networkDoc/http.html#http1-0-2-0区别" class="sidebar-link">http1.0/2.0区别</a></li><li class="sidebar-sub-header"><a href="/networkDoc/http.html#http报文" class="sidebar-link">http报文</a></li><li class="sidebar-sub-header"><a href="/networkDoc/http.html#请求方法" class="sidebar-link">请求方法</a></li><li class="sidebar-sub-header"><a href="/networkDoc/http.html#状态码" class="sidebar-link">状态码</a></li><li class="sidebar-sub-header"><a href="/networkDoc/http.html#connection为keep-alive表示什么" class="sidebar-link">connection为keep-alive表示什么</a></li><li class="sidebar-sub-header"><a href="/networkDoc/http.html#get和post区别" class="sidebar-link">get和post区别</a></li></ul></li><li><a href="/networkDoc/https.html" class="sidebar-link">Https</a></li><li><a href="/networkDoc/iframe.html" class="sidebar-link">iframe</a></li><li><a href="/networkDoc/origin.html" class="sidebar-link">跨域</a></li><li><a href="/networkDoc/tcp.html" class="sidebar-link">TCP</a></li><li><a href="/networkDoc/urlDesc.html" class="sidebar-link">输入一个url发生了什么</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http协议"><a href="#http协议" class="header-anchor">#</a> http协议</h1> <p><strong>HTTP是不保存状态的协议</strong>，既无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此<strong>连接双方不能知晓对方当前的身份和状态</strong>。这也是Cookie技术产生的重要原因之一：客户端的状态管理。浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保持 Cookie。而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务端识别客户端身份状态的标识。</p> <h2 id="http"><a href="#http" class="header-anchor">#</a> http</h2> <h3 id="tcp-ip协议族"><a href="#tcp-ip协议族" class="header-anchor">#</a> tcp/IP协议族</h3> <p>TCP/IP 协议族是Internet最基本的协议，HTTP协议是它的一个子集。TCP/IP协议族按层次分为以下四层
应用层、传输层、网络层、链路层、</p> <h3 id="串行连接、持久连接、管道化持久连接、http-2-0多路复用简介"><a href="#串行连接、持久连接、管道化持久连接、http-2-0多路复用简介" class="header-anchor">#</a> 串行连接、持久连接、管道化持久连接、http/2.0多路复用简介</h3> <ul><li><strong>串行连接</strong>： HTTP有无连接的特性，即每次连接只能处理一个请求，收到响应后立即断开连接。HTTP/1.0 版本（称为串行连接或短连接、短轮询）中每次HTTP通信后都要断开TCP连接，所以每个新的HTTP请求都需要建立一个新的连接。并且每次请求都建立新的tcp连接（每次都有三次握手四次挥别）极大的增加了通信开销。==总结：串行连接每次发起请求都必须建立新的tcp连接。==</li> <li><strong>持久连接</strong>： 为解决这个问题，有人提出了持久连接（也叫长连接、长轮询）。一定时间内，<strong>同一域名下的HTTP请求，只要两端都没有提出断开连接，则持久保持TCP连接状态</strong>，其他请求可以复用这个连接通道。<strong>HTTP/1.1 实现并默认了所有连接都是持久连接</strong>，这样客户端发起多个HTTP请求时就减少了TCP握手造成的网络资源和通信时间的浪费。==但是持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起==。==总结：持久连接多个http请求可以复用同一个tcp连接，但是下次请求必须在上次响应返回之后进行。==</li> <li><strong>管道化持久连接</strong>： 管道化则可以不用等待响应返回而发送下个==请求并按顺序返回响应==，现代浏览器并未默认开启管道化。==总结：管道化持久连接也可以复用同一个tcp连接，并且可以不用等待发出多个http请求，但是响应必须按顺序返回==。</li> <li><strong>HTTP/2.0多路复用</strong>： 每个HTTP请求都有一个序列标识符，这样浏览器可以==并发多个请求==，服务器接收到数据后，再==根据序列标识符重新排序成不同的请求报文，而不会导致数据错乱==。同样，服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文。并且==同一个域名下的所有请求都复用同一个TCP连接，极大增加了服务器处理并发的上限==。</li> <li><strong>WebSocket</strong>： WebSocket是HTML5提出的一种==客户端和服务端通讯的全双工协议==，由客户端发起请求，建立连接之后不仅客户端可以主动向服务端发送请求，==服务端可以主动向客户端推送信息==。</li></ul> <p>疑问：管道持久化和多路复用有什么区别？？？</p> <h2 id="http1-0-2-0区别"><a href="#http1-0-2-0区别" class="header-anchor">#</a> http1.0/2.0区别</h2> <h3 id="http-1-0"><a href="#http-1-0" class="header-anchor">#</a> HTTP/1.0</h3> <p>最早的http只是使用在一些较为简单的网页上和网络请求上，所以比较简单，<strong>每次请求都打开一个新的TCP链接，收到响应之后立即断开连接</strong>。</p> <h3 id="http-1-1"><a href="#http-1-1" class="header-anchor">#</a> HTTP/1.1</h3> <ul><li>HTTP/1.1 引入了更多的==缓存控制策略==，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等</li> <li>HTTP/1.1 允许范围请求，即在请求头中加入==Range==头部</li> <li>HTTP/1.1 的请求消息和响应消息都必须包含==Host==头部，以区分同一个物理主机中的不同虚拟主机的域名</li> <li>HTTP/1.1 ==默认开启持久连接==，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</li></ul> <p>补充：</p> <ul><li>长连接：一个tcp/ip连接上可以连续发送多个数据包</li></ul> <h3 id="http-2-0"><a href="#http-2-0" class="header-anchor">#</a> HTTP/2.0</h3> <p>在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。
帧代表数据传输的最小的单位，每个帧都有序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。</p> <ul><li><strong>新的二进制格式</strong>： HTTP/1.x的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景必然很多。基于这种考虑==HTTP/2.0的协议解析采用二进制格式==，方便且强大。</li> <li><strong>多路复用</strong>： HTTP/2.0支持多路复用，这是HTTP/1.1持久连接的升级版。==多路复用可以发送多个请求==，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。</li> <li><strong>头部压缩</strong>： HTTP/1.x的请求和响应头部带有大量信息，而且每次请求都要重复发送，==HTTP/2.0使用encoder来减少需要传输的头部大小==，通讯双方各自cache一份头部 fields表，既避免了重复头部的传输，又减小了需要传输的大小。</li> <li><strong>服务端推送</strong>：
HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是被动的响应请求。也可以==新建“流”主动向客户端发送消息==。比如在浏览器刚请求HTML的时候就提前把可能会用到的js、css文件发送给客户端，减少等待的延迟，这就成为“服务端推送”（server push）。</li></ul> <p>其他补充：</p> <ul><li>==HTTP1.1==虽然减少连接带来的性能消耗，但是==请求最大并发受到限制==，同一域下的HTTP连接数根据浏览器不同有所变化，==一般是6 ~ 8个==。而且一个TCP连接同一时刻只能处理一个请求，当前请求未结束之前，其他请求只能处于阻塞状态。</li> <li>HTTP2.0中增加“多路复用”的机制，不再受限于浏览器的连接数限制。基于二进制分帧，客户端发送的数据会被分割成带有编号的碎片（二进制帧），然后将这些碎片同时发送给服务端，服务端接收到数据后根据编号再合并成完整的数据。服务端返回数据也同样遵循这个过程。</li></ul> <h3 id="http-3-0"><a href="#http-3-0" class="header-anchor">#</a> HTTP/3.0</h3> <p>HTTP/2.0 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中==出现了丢包的情况，那就会导致整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了==。出现包阻塞的原因是因为底层TCP协议导致的问题，Google 基于 UDP 协议推出了一个的 QUIC 协议，并且使用在了 HTTP/3 上。</p> <p>QUIC 基于 UDP，但是UDP本身存在不稳定性等诸多问题，所以QUIC在UDP的基础上新增了很多功能，比如<strong>多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能</strong>。</p> <ul><li><strong>避免包阻塞</strong>： 多个流的数据包在TCP连接上传输时，若一个流中的数据包传输出现问题，TCP需要等待该包重传后，才能继续传输其它流的数据包（TCP的队头阻塞没有彻底解决）。但在==基于UDP的QUIC协议中==，不同的流之间的数据传输真正实现了相互独立互不干扰，==某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响==。</li> <li><strong>快速重启会话</strong>： 普通基于tcp的连接，是基于两端的ip和端口和协议来建立的。在网络切换场景，例如手机端切换了无线网，使用4G网络，会改变本身的ip，这就导致tcp连接必须重新创建。而==QUIC协议使用特有的UUID来标记每一次连接，在网络环境发生变化的时候，只要UUID不变，就能不需要握手，继续传输数据==。</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>HTTP/1.1有两个主要的缺点：安全性不足和性能不高。
HTTP/2 完全兼容HTTP/1 ，是“更安全的HTTP、更快的HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验。
QUIC基于UDP实现，是HTTP/3中的底层协议，该协议基于UDP，又提取了TCP中的精华，实现了即快又可靠的协议。</p> <h2 id="http报文"><a href="#http报文" class="header-anchor">#</a> http报文</h2> <p>用于HTTP协议交互的信息被称为HTTP报文。客户端的HTTP报文叫请求报文，服务端的HTTP报文叫响应报文。</p> <ul><li><code>请求报文</code> 是由请求行（请求方法、协议版本）、请求首部（请求URI、客户端信息等）和内容实体（用户信息和资源信息等，可为空）构成。</li> <li><code>响应报文</code>是由状态行（协议版本、状态码）、响应首部（服务器名称、资源标识等）和内容实体（服务端返回的资源信息）构成。</li></ul> <h2 id="请求方法"><a href="#请求方法" class="header-anchor">#</a> 请求方法</h2> <ul><li>GET：get方法一般用于获取服务器资源</li> <li>POST：post方法一般用于传输实体主体</li> <li>PUT：put方法一般用于传输文件</li> <li>DELETE：delete方法用于删除文件</li> <li>HEAD：head方法用于获取报文首部，不返回报文主体</li> <li>OPTIONS：options方法用于询问请求URI资源支持的方法
补充
1、以上请求的使用场景
2、请求数据只能用get请求吗
3、get和post的区别
4、restful API</li></ul> <h2 id="状态码"><a href="#状态码" class="header-anchor">#</a> 状态码</h2> <ul><li>2xx 成功，请求被正常处理</li> <li>3xx  重定向，表示浏览器要执行特殊处理</li> <li>4xx  客户端错误</li> <li>5xx  服务器错误</li></ul> <p>几个常考的错误码数</p> <ul><li>200  ok ，表示从客户端发来的请求在服务端被正确处理</li> <li>206  进行范围请求成功。客户端发送了一个带range头的请求，服务端完成了他。响应体中只有range头中指定的这部分。</li> <li>301  所请求的页面已经转移到新的URL（永久）</li> <li>302  所请求的页面已经临时转移到新的URL（临时）</li> <li>304  如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容并没有改变，则服务器应当返回这个状态码。304响应也是一种缓存机制。Web服务器对静态资源文件通常会采取缓存，因此在Web开发中你可以看到大量的304响应。 服务器给出的相应中通常会包含Etag来标识资源ID</li> <li>401 （未授权）请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。</li> <li>403  服务器拒绝请求。</li></ul> <h2 id="connection为keep-alive表示什么"><a href="#connection为keep-alive表示什么" class="header-anchor">#</a> connection为keep-alive表示什么</h2> <p>HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；keep-alive（持久连接）是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。</p> <p>在 HTTP/1.0 协议中，如果请求头中包含：</p> <div class="language- extra-class"><pre class="language-text"><code>Connection: keep-alive

</code></pre></div><p>则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。</p> <p>在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：</p> <div class="language- extra-class"><pre class="language-text"><code>Connection: close

</code></pre></div><h2 id="get和post区别"><a href="#get和post区别" class="header-anchor">#</a> get和post区别</h2> <ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li> <li>GET产生的URL地址可以被Bookmark，而POST不可以。</li> <li>GET请求会被浏览器==主动cache==，而POST不会，除非手动设置。</li> <li>GET请求只能进行url编码，而POST支持多种编码方式。</li> <li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li> <li>GET请求在URL中传送的参数是有==长度限制==的，而POST么有。</li> <li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li> <li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。（body中的信息也可以获取到）</li> <li>GET参数通过URL传递，POST放在Request body中。（一般规定这样，但是get也可以带body）</li></ul> <p>以上答案都不是面试官想听到的，了解即可。</p> <p><strong>GET产生一个TCP数据包；POST产生两个TCP数据包</strong>。</p> <ul><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</li> <li>而对于POST，==浏览器先发送header==，服务器响应100 continue，浏览器==再发送data==，服务器响应200 ok（返回数据）。因为POST需要两步，时间上消耗的要多一点。</li> <li>在网络环境好的情况下，发一次包的时间和发==两次包的时间差别基本可以无视==。而在网络环境差的情况下，==两次包的TCP在验证数据包完整性上，有非常大的优点==。</li></ul> <ol start="3"><li>并不是所有浏览器都会在POST中发送两次包，==Firefox就只发送一次==。</li></ol> <h3 id="相同之处"><a href="#相同之处" class="header-anchor">#</a> 相同之处</h3> <p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p> <h3 id="关于安全性"><a href="#关于安全性" class="header-anchor">#</a> 关于安全性</h3> <p>我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，==无论是GET还是POST都不够安全，因为HTTP本身是明文协议==。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。==这完全不是一个“是否容易在浏览器地址栏上看到“的问题==。为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是https——即用SSL协议协商出的密钥加密明文的http数据。这个加密的协议和HTTP协议本身相互独立。如果是利用HTTP开发公网的站点/App，要保证安全，==https是最最基本的要求==。</p> <p>的确GET请求的参数更倾向于放在url上，因此有更多机会被泄漏。比如==携带私密信息的url会展示在地址栏上，还可以分享给第三方，就非常不安全了==。此外，从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的access log通常会输出完整的url，比如nginx的默认access log就是如此。如果==url上携带敏感数据，就会被记录下来==。但请注意，==就算私密数据在body里，也是可以被记录下来的==，因此如果请求要经过不信任的公网，避免泄密的唯一手段就是https。</p> <p>问题：
Get.post区别，为什么删除不能用get
答案：1、url可以容易被分享  2、容易被篡改 3、数据包1个和2个的问题，2个完整性更好  4、发送数据大小</p> <p>get能否加body
Apache Http Client 和  OkHttpClient 都不支持  GET 请求发送 Body 数据，而 AsyncHttpClient 是可以的。主要是 GET 被设计来用 URI 来识别资源，如果让它的请求体中携带数据，那么通常的缓存服务便失效了，URI 不能作为缓存的 Key。</p> <p>参考链接</p> <ul><li><a href="https://juejin.im/post/6844903844216832007" target="_blank" rel="noopener noreferrer">前端基础篇之HTTP协议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://harttle.land/2015/08/15/http-status-code.html#header-11" target="_blank" rel="noopener noreferrer">如何理解HTTP响应的状态码？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://lotabout.me/2019/Things-about-keepalive/" target="_blank" rel="noopener noreferrer">HTTP keep-alive二三事<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://byvoid.com/zhs/blog/http-keep-alive-header/" target="_blank" rel="noopener noreferrer">HTTP 协议头部与Keep-alive模式详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw%3D%3D&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4" target="_blank" rel="noopener noreferrer">99%的人都理解错了HTTP中GET与POST的区别<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener noreferrer">GET 和 POST 到底有什么区别？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://blog.csdn.net/qq_26878363/article/details/86506369?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-86506369.nonecase" target="_blank" rel="noopener noreferrer">关于Http Get请求是否可携带Body<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://segmentfault.com/a/1190000020714686#articleHeader16" target="_blank" rel="noopener noreferrer">解密HTTP/2与HTTP/3的新特性<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/6869376045636648973?utm_source=gold_browser_extension" target="_blank" rel="noopener noreferrer">金九银十，初中级前端面试复习总结「浏览器、HTTP、前端安全」<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/networkDoc/dns.html" class="prev">
        DNS
      </a></span> <span class="next"><a href="/networkDoc/https.html">
        Https
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.df490d21.js" defer></script><script src="/assets/js/2.9235f093.js" defer></script><script src="/assets/js/19.3bd23e42.js" defer></script>
  </body>
</html>
