(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{373:function(n,e,t){"use strict";t.r(e);var a=t(42),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[n._v("#")]),n._v(" 路由")]),n._v(" "),t("h2",{attrs:{id:"spa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spa"}},[n._v("#")]),n._v(" SPA")]),n._v(" "),t("p",[n._v("SPA 是 single page web application 的简称，译为单页Web应用。\n简单的说 SPA 就是一个WEB项目只有一个 HTML 页面，一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转。\n取而代之的是利用 JS 动态的变换 HTML 的内容，从而来模拟多个视图间跳转。")]),n._v(" "),t("p",[n._v("但由于 SPA 中用户的交互是通过 JS 改变 HTML 内容来实现的，页面本身的 url 并没有变化，这导致了两个问题：")]),n._v(" "),t("ol",[t("li",[n._v("SPA 无法记住用户的操作记录，无论是刷新、前进还是后退，都无法展示用户真实的期望内容。")]),n._v(" "),t("li",[n._v("SPA 中虽然由于业务的不同会有多种页面展示形式，但只有一个 url，对 SEO 不友好，不方便搜索引擎进行收录。")])]),n._v(" "),t("p",[n._v("前端路由就是为了解决上述问题而出现的。")]),n._v(" "),t("p",[n._v("对于单页应用的 history 模式而言，url 的改变只能由下面四种方式引起：")]),n._v(" "),t("ul",[t("li",[n._v("点击浏览器的前进或后退按钮")]),n._v(" "),t("li",[n._v("点击 a 标签（hash模式实现路由）")]),n._v(" "),t("li",[n._v("在 JS 代码中触发 history.pushState 函数")]),n._v(" "),t("li",[n._v("在 JS 代码中触发 history.replaceState 函数")])]),n._v(" "),t("h2",{attrs:{id:"hash实现路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash实现路由"}},[n._v("#")]),n._v(" hash实现路由")]),n._v(" "),t("p",[n._v('这里的 hash 就是指 url 后的 # 号以及后面的字符。比如说 "www.baidu.com/#hashhash" ，其中 "#hashhash" 就是我们期望的 hash 值。\n==由于 hash 值的变化不会导致浏览器像服务器发送请求，而且 hash 的改变会触发 hashchange 事件，浏览器的前进后退也能对其进行控制==')]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class HashRouter{\n    constructor(){\n        //用于存储不同hash值对应的回调函数\n        this.routers = {};\n        window.addEventListener('hashchange',this.load.bind(this),false)\n    }\n    //用于注册每个视图\n    register(hash,callback = function(){}){\n        this.routers[hash] = callback;\n    }\n    //用于注册首页\n    registerIndex(callback = function(){}){\n        this.routers['index'] = callback;\n    }\n    //用于处理视图未找到的情况\n    registerNotFound(callback = function(){}){\n        this.routers['404'] = callback;\n    }\n    //用于处理异常情况\n    registerError(callback = function(){}){\n        this.routers['error'] = callback;\n    }\n    //用于调用不同视图的回调函数\n    load(){\n        let hash = location.hash.slice(1),\n            handler;\n        //没有hash 默认为首页\n        if(!hash){\n            handler = this.routers.index;\n        }\n        //未找到对应hash值\n        else if(!this.routers.hasOwnProperty(hash)){\n            handler = this.routers['404'] || function(){};\n        }\n        else{\n            handler = this.routers[hash]\n        }\n        //执行注册的回调函数\n        try{\n            handler.apply(this);\n        }catch(e){\n            console.error(e);\n            (this.routers['error'] || function(){}).call(this,e);\n        }\n    }\n}\n\n\nlet router = new HashRouter();\nlet container = document.getElementById('container');\n\n//注册首页回调函数\nrouter.registerIndex(()=> container.innerHTML = '我是首页');\n\n//注册其他视图回到函数\nrouter.register('/page1',()=> container.innerHTML = '我是page1');\nrouter.register('/page2',()=> container.innerHTML = '我是page2');\nrouter.register('/page3',()=> container.innerHTML = '我是page3');\nrouter.register('/page4',()=> {throw new Error('抛出一个异常')});\n\n//加载视图\nrouter.load();\n//注册未找到对应hash值时的回调\nrouter.registerNotFound(()=>container.innerHTML = '页面未找到');\n//注册出现异常时的回调\nrouter.registerError((e)=>container.innerHTML = '页面异常，错误消息：<br>' + e.message);\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<body>\n    <div id="nav">\n        <a href="#/page1">page1</a>\n        <a href="#/page2">page2</a>\n        <a href="#/page3">page3</a>\n    </div>\n    <div id="container"></div>\n</body>\n\n')])])]),t("ol",[t("li",[n._v("通过href触发hash值的改变")]),n._v(" "),t("li",[n._v("通过hashchange监听hash值的改变")]),n._v(" "),t("li",[n._v("hash值改变的时候执行回调，修改当前页面")]),n._v(" "),t("li",[n._v("registerNotFound 方法，用于注册 hash 值未找到时的默认回调函数；")]),n._v(" "),t("li",[n._v("增加 try/catch 用于捕获异常")]),n._v(" "),t("li",[n._v("registerError 方法，用于处理异常")])]),n._v(" "),t("h2",{attrs:{id:"history-模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#history-模式"}},[n._v("#")]),n._v(" history 模式")]),n._v(" "),t("p",[n._v("在 HTML5 的规范中，history 新增了以下几个 API：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("history.pushState();     // 添加新的状态到历史状态栈\nhistory.replaceState();  // 用新的状态代替当前状态\nhistory.state            // 返回当前状态对象\n\n")])])]),t("p",[n._v("history.pushState() 和 history.replaceState() 的区别在于：")]),n._v(" "),t("ul",[t("li",[n._v("history.pushState() 在保留现有历史记录的同时，将 url 加入到历史记录中。")]),n._v(" "),t("li",[n._v("history.replaceState() 会将历史记录中的当前页面历史替换为 url。（区别在后退时跳转不一致）")])]),n._v(" "),t("p",[n._v("==由于 history.pushState() 和 history.replaceState() 可以改变 url 同时，不会刷新页面==，所以在 HTML5 中的 histroy 具备了实现前端路由的能力。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class HistoryRouter{\n    constructor(){\n        //用于存储不同path值对应的回调函数\n        this.routers = {};\n        this.listenPopState();\n        this.listenLink();\n    }\n    //监听popstate\n    listenPopState(){\n    //监听 popstate 用于处理前进后退时调用对应的回调函数\n        window.addEventListener('popstate',(e)=>{\n            let state = e.state || {},\n                path = state.path || '';\n            this.dealPathHandler(path)\n        },false)\n    }\n    //全局监听A链接\n    listenLink(){\n    //全局阻止A链接的默认事件，获取A链接的href属性，并调用 history.pushState 方法\n        window.addEventListener('click',(e)=>{\n            let dom = e.target;\n            if(dom.tagName.toUpperCase() === 'A' && dom.getAttribute('href')){\n                e.preventDefault()\n                this.assign(dom.getAttribute('href'));\n            }\n        },false)\n    }\n    //用于首次进入页面时调用\n    load(){\n        let path = location.pathname;\n        this.dealPathHandler(path)\n    }\n    //用于注册每个视图\n    register(path,callback = function(){}){\n        this.routers[path] = callback;\n    }\n    //用于注册首页\n    registerIndex(callback = function(){}){\n        this.routers['/'] = callback;\n    }\n    //用于处理视图未找到的情况\n    registerNotFound(callback = function(){}){\n        this.routers['404'] = callback;\n    }\n    //用于处理异常情况\n    registerError(callback = function(){}){\n        this.routers['error'] = callback;\n    }\n    //跳转到path\n    assign(path){\n        history.pushState({path},null,path);\n        this.dealPathHandler(path)\n    }\n    //替换为path\n    replace(path){\n        history.replaceState({path},null,path);\n        this.dealPathHandler(path)\n    }\n    //通用处理 path 调用回调函数\n    dealPathHandler(path){\n        let handler;\n        //没有对应path\n        if(!this.routers.hasOwnProperty(path)){\n            handler = this.routers['404'] || function(){};\n        }\n        //有对应path\n        else{\n            handler = this.routers[path];\n        }\n        try{\n            handler.call(this)\n        }catch(e){\n            console.error(e);\n            (this.routers['error'] || function(){}).call(this,e);\n        }\n    }\n}\n\n\nlet router = new HistoryRouter();\nlet container = document.getElementById('container');\n\n//注册首页回调函数\nrouter.registerIndex(() => container.innerHTML = '我是首页');\n\n//注册其他视图回到函数\nrouter.register('/page1', () => container.innerHTML = '我是page1');\nrouter.register('/page2', () => container.innerHTML = '我是page2');\nrouter.register('/page3', () => container.innerHTML = '我是page3');\nrouter.register('/page4', () => {\n    throw new Error('抛出一个异常')\n});\n\ndocument.getElementById('btn').onclick = () => router.assign('/page2')\n\n\n//注册未找到对应path值时的回调\nrouter.registerNotFound(() => container.innerHTML = '页面未找到');\n//注册出现异常时的回调\nrouter.registerError((e) => container.innerHTML = '页面异常，错误消息：<br>' + e.message);\n//加载页面\nrouter.load();\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<body>\n    <div id="nav">\n        <a href="/page1">page1</a>\n        <a href="/page2">page2</a>\n        <a href="/page3">page3</a>\n        <a href="/page4">page4</a>\n        <a href="/page5">page5</a>\n        <button id="btn">page2</button>\n    </div>\n    <div id="container">\n\n    </div>\n</body>\n\n')])])]),t("p",[n._v("history 在修改 url 后，虽然页面并不会刷新，==但我们在手动刷新，或通过 url 直接进入应用的时候，\n服务端是无法识别这个 url 的。因为我们是单页应用，只有一个 html 文件，服务端在处理其他路径的 url 的时候，就会出现404的情况==。\n所以，如果要应用 history 模式，==需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回单页应用的 html 文件==。")]),n._v(" "),t("p",[n._v("hash 模式相比于 history 模式的优点")]),n._v(" "),t("ul",[t("li",[n._v("兼容性更好，可以兼容到IE8")]),n._v(" "),t("li",[n._v("无需服务端配合处理非单页的url地址")])]),n._v(" "),t("p",[n._v("hash 模式相比于 history 模式的缺点：")]),n._v(" "),t("ul",[t("li",[n._v("看起来更丑。")]),n._v(" "),t("li",[n._v("会导致锚点功能失效。")]),n._v(" "),t("li",[n._v("相同 hash 值不会触发动作将记录加入到历史栈中，而 pushState 则可以。")])]),n._v(" "),t("p",[n._v("综上所述，当我们不需要兼容老版本IE浏览器，并且可以控制服务端覆盖所有情况的候选资源时，我们可以愉快的使用 history 模式了。")])])}),[],!1,null,null,null);e.default=r.exports}}]);