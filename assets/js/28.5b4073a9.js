(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{375:function(e,n,t){"use strict";t.r(n);var o=t(42),a=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue源码"}},[e._v("#")]),e._v(" vue源码")]),e._v(" "),t("h2",{attrs:{id:"源码目录及准备工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码目录及准备工作"}},[e._v("#")]),e._v(" 源码目录及准备工作")]),e._v(" "),t("p",[e._v("直接看链接\n"),t("a",{attrs:{href:"https://ustbhuangyi.github.io/vue-analysis/v2/prepare/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js 技术揭秘/准备工作"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"源码断点调试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码断点调试"}},[e._v("#")]),e._v(" 源码断点调试")]),e._v(" "),t("p",[e._v("调试是在使用vue的项目里，不是在vue的源码项目中。")]),e._v(" "),t("p",[e._v("在项目中引入vue")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import Vue from 'vue'\nvar app=new Vue({\n    el:'#app',\n    data:{\n        message:'hello word!'\n    }\n})\n")])])]),t("p",[e._v("正常情况下，对应引入的文件从node_modules中找\n"),t("code",[e._v("node_modules/vue/package.json")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('"module":"dist/vue.runtime.esm.js" //module指向的地址\n\n')])])]),t("p",[e._v("webpack的配置")]),e._v(" "),t("p",[e._v("如果是compiler版本则会自动在配置文件中加上"),t("code",[e._v("vue")]),e._v("别名这一行定义。则当"),t("code",[e._v("import vue")]),e._v("时，从以下路径中寻找。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("resolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {//定义的别名\n      'vue': resolve('node_modules/vue/dist/vue.esm.js'),\n      '@': resolve('src'),\n    }\n  },\n")])])]),t("p",[e._v("打开"),t("code",[e._v("node_modules/vue/dist/vue.esm.js")]),e._v("，搜索init方法,加入断点。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n  \n  debugger\n  \n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n    }\n}\n")])])]),t("h3",{attrs:{id:"runtime-only-vs-runtime-compiler（版本介绍）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runtime-only-vs-runtime-compiler（版本介绍）"}},[e._v("#")]),e._v(" Runtime Only VS Runtime + Compiler（版本介绍）")]),e._v(" "),t("p",[e._v("通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本。")]),e._v(" "),t("p",[e._v("下面我们来对比这两个版本：")]),e._v(" "),t("ul",[t("li",[e._v("Runtime Only\n我们在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。这个版本不支持.vue文件的写法。")]),e._v(" "),t("li",[e._v("Runtime + Compiler\n我们如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板。目前项目使用这个版本。如下所示：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 需要编译器的版本\nnew Vue({\n  template: '<div>{{ hi }}</div>'\n})\n\n// 这种情况不需要\nnew Vue({\n  render (h) {\n    return h('div', this.hi)\n  }\n})\n")])])]),t("blockquote",[t("p",[e._v("因为在 Vue.js 2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。")])]),e._v(" "),t("h3",{attrs:{id:"疑问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#疑问"}},[e._v("#")]),e._v(" 疑问")]),e._v(" "),t("ol",[t("li",[e._v("nodemodule中的vue文件目录和源码中文件目录的那些代码有什么关系")])]),e._v(" "),t("h2",{attrs:{id:"数据驱动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据驱动"}},[e._v("#")]),e._v(" 数据驱动")]),e._v(" "),t("h3",{attrs:{id:"new-vue发生了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new-vue发生了什么"}},[e._v("#")]),e._v(" new vue发生了什么")]),e._v(" "),t("p",[e._v("Vue 实际上是一个类，类在 Javascript 中是用 Function 来实现的，来看一下源码，在"),t("code",[e._v("src/core/instance/index.js")]),e._v(" 中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Vue (options) {\n  // ...\n  this._init(options)\n}\n")])])]),t("p",[e._v("然后会调用 "),t("code",[e._v("this._init")]),e._v(" 方法， 该方法在 "),t("code",[e._v("src/core/instance/init.js")]),e._v(" 中定义。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype._init = function (options?: Object) {\n   // ...\n \n  // merge options 合并配置\n  if (options && options._isComponent) {\n   // ...\n  } else {\n    vm.$options = mergeOptions(\n      resolveConstructorOptions(vm.constructor),\n      options || {},\n      vm\n    )\n  }\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    initProxy(vm)\n  } else {\n    vm._renderProxy = vm\n  }\n  // 初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等\n  vm._self = vm\n  initLifecycle(vm)\n  initEvents(vm)\n  initRender(vm)\n  callHook(vm, 'beforeCreate')\n  initInjections(vm) // resolve injections before data/props\n  initState(vm)\n  initProvide(vm) // resolve provide after data/props\n  callHook(vm, 'created')\n\n   // ...\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el) //挂载\n  }\n}\n")])])]),t("blockquote",[t("ul",[t("li",[e._v("Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。")]),e._v(" "),t("li",[e._v("在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM，那么接下来我们来分析 Vue 的挂载过程。")])])]),e._v(" "),t("h3",{attrs:{id:"vue实例挂载实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue实例挂载实现"}},[e._v("#")]),e._v(" vue实例挂载实现")]),e._v(" "),t("p",[e._v("Vue 中我们是通过 "),t("code",[e._v("$mount")]),e._v(" 实例方法去挂载 "),t("code",[e._v("vm")]),e._v(" 的，"),t("code",[e._v("$mount")]),e._v(" 方法在多个文件中都有定义，因为 "),t("code",[e._v("$mount")]),e._v(" 这个方法的实现是和平台、构建方式都相关的。")]),e._v(" "),t("ul",[t("li",[e._v("src/platform/web/entry-runtime-with-compiler.js --仅在compiler 版本存在")]),e._v(" "),t("li",[e._v("src/platform/web/runtime/index.js     --web端")]),e._v(" "),t("li",[e._v("src/platform/weex/runtime/index.js    --weex")])]),e._v(" "),t("p",[t("code",[e._v("compiler")]),e._v(" 版本的 "),t("code",[e._v("$mount")]),e._v(" 实现非常有意思，先来看一下 "),t("code",[e._v("src/platform/web/entry-runtime-with-compiler.js")]),e._v(" 文件中定义：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/*1、缓存了原型上的 $mount 方法，再重新定义该方法*/\nconst mount = Vue.prototype.$mount \nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && query(el)\n\n  /*2、对el做限制*/\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n    return this\n  }\n  const options = this.$options\n  /*3、把 el 或者 template 字符串转换成 render 方法 */\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n         // ...\n        /*在线编译过程，返回render函数 */\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      /* istanbul ignore if */\n       // ...\n    }\n  }\n  /*4、最后调用原型上的$mount挂载 */\n  return mount.call(this, el, hydrating)\n}\n")])])]),t("blockquote",[t("ol",[t("li",[e._v("首先缓存了原型上的 $mount 方法，再重新定义该方法，我们先来分析这段代码。")]),e._v(" "),t("li",[e._v("对 el 做了限制，Vue 不能挂载在 body、html 这样的根节点上。")]),e._v(" "),t("li",[e._v("把 el 或者 template 字符串转换成 render 方法。这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 template 属性，最终都会转换成 render 方法，那么这个过程是 Vue 的一个“在线编译”的过程，它是调用 compileToFunctions 方法实现的，编译过程我们之后会介绍。")]),e._v(" "),t("li",[e._v("最后调用原先原型上的 $mount 方法挂载。")])])]),e._v(" "),t("p",[e._v("原先原型上的 $mount 方法在 "),t("code",[e._v("src/platform/web/runtime/index.js")]),e._v(" 中定义,因为它可以被 "),t("code",[e._v("runtime only")]),e._v(" 版本的 Vue 直接使用的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element, /*表示挂载的元素，可以是字符串，也可以是 DOM 对象*/\n  hydrating?: boolean, /*和服务端渲染相关 */\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating)\n}\n")])])]),t("p",[t("code",[e._v("$mount")]),e._v(" 方法实际上会去调用 "),t("code",[e._v("mountComponent")]),e._v(" 方法，这个方法定义在 "),t("code",[e._v("src/core/instance/lifecycle.js")]),e._v(" 文件中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n\n    /* 一些警告及错误提示 */\n     // ...\n    \n  }\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* 调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n //实例化一个渲染watcher\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted) {\n        callHook(vm, 'beforeUpdate')\n      }\n    }\n  }, true /* isRenderWatcher */)\n  hydrating = false\n\n\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n\n")])])]),t("p",[e._v("mountComponent 核心")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("先实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法。")]),e._v(" "),t("li",[e._v("在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。")])])]),e._v(" "),t("p",[e._v("Watcher 在这里起到两个作用")]),e._v(" "),t("blockquote",[t("ol",[t("li",[e._v("一个是初始化的时候会执行回调函数")]),e._v(" "),t("li",[e._v("另一个是当 vm实例中的监测的数据发生变化的时候执行回调函数")])])]),e._v(" "),t("h3",{attrs:{id:"render"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[e._v("#")]),e._v(" render")]),e._v(" "),t("p",[e._v("Vue 的"),t("code",[e._v("_render")]),e._v(" 方法是实例的一个私有方法，用来把实例渲染成一个"),t("code",[e._v("V Node")]),e._v("。它的定义在 src/core/instance/render.js 文件中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype._render = function (): VNode {\n  const vm: Component = this\n  const { render, _parentVnode } = vm.$options\n\n  // ...\n\n  vm.$vnode = _parentVnode\n  // render self\n  let vnode\n  try {\n    //重点\n    vnode = render.call(vm._renderProxy, vm.$createElement)\n  } catch (e) {\n    handleError(e, vm, `render`)\n     // ...\n  }\n  // return empty vnode in case the render function errored out\n  if (!(vnode instanceof VNode)) {\n     // ...\n    vnode = createEmptyVNode()\n  }\n  // set parent\n  vnode.parent = _parentVnode\n  return vnode\n}\n")])])]),t("h4",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("blockquote",[t("p",[e._v("vm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node。")])]),e._v(" "),t("h3",{attrs:{id:"virtual-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[e._v("#")]),e._v(" Virtual DOM")]),e._v(" "),t("p",[e._v("VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。")]),e._v(" "),t("h4",{attrs:{id:"createelement"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#createelement"}},[e._v("#")]),e._v(" createElement")]),e._v(" "),t("p",[e._v("Vue.js 利用 createElement 方法创建 VNode，它定义在 src/core/vdom/create-elemenet.js 中")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function createElement (\n  context: Component,\n  tag: any,\n  data: any,\n  children: any,\n  normalizationType: any,\n  alwaysNormalize: boolean\n): VNode | Array<VNode> {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children\n    children = data\n    data = undefined\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE\n  }\n  /* 初始化状态 */\n  return _createElement(context, tag, data, children, normalizationType)\n}\n")])])]),t("p",[e._v("真正创建 VNode 的函数 _createElement")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function _createElement (\n  context: Component,\n  tag?: string | Class<Component> | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode | Array<VNode> {\n  if (isDef(data) && isDef((data: any).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` +\n      'Always create fresh vnode data objects in each render!',\n      context\n    )\n    return createEmptyVNode()\n  }\n  \n  // ... 状态判断\n  \n  /*1、 children的规范化 */\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children)//重点\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children) //重点\n  }\n  \n  /* 2、创建VNode实例 */\n  let vnode, ns\n  if (typeof tag === 'string') {\n    let Ctor\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n    if (config.isReservedTag(tag)) {//内置节点\n      // 创建普通VNode\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      )\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {//已注册的组件名\n      // 创建一个组件类型的VNode\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {//否则创建一个未知标签的VNode\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      )\n    }\n  } else {\n    //如果是 tag 一个 Component 类型，则直接调用 createComponent 创建一个组件类型的 VNode 节点。\n    vnode = createComponent(tag, data, context, children)\n  }\n  \n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) applyNS(vnode, ns)\n    if (isDef(data)) registerDeepBindings(data)\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n")])])]),t("p",[e._v("_createElement 方法有 5 个参数：")]),e._v(" "),t("ul",[t("li",[e._v("context 表示 VNode 的上下文环境，它是 Component 类型；")]),e._v(" "),t("li",[e._v("tag 表示标签，它可以是一个字符串，也可以是一个 Component；data 表示 VNode 的数据，它是一个 VNodeData 类型；")]),e._v(" "),t("li",[e._v("children 表示当前 VNode 的子节点，它是任意类型的，它接下来需要被规范为标准的 VNode 数组；")]),e._v(" "),t("li",[e._v("normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，它主要是参考 render 函数是编译生成的还是用户手写的。")])]),e._v(" "),t("p",[e._v("children 的规范化以及 VNode 的创建")]),e._v(" "),t("ul",[t("li",[e._v("simpleNormalizeChildren 方法调用场景是 render 函数是编译生成的。理论上编译生成的 children 都已经是 VNode 类型的，但这里有一个例外，就是 functional component 函数式组件返回的是一个数组而不是一个根节点，所以会通过 Array.prototype.concat 方法把整个 children 数组打平，让它的深度只有一层。")]),e._v(" "),t("li",[e._v("normalizeArrayChildren 主要的逻辑就是遍历 children，获得单个节点 c，然后对 c 的类型判断，如果是一个数组类型，则递归调用 normalizeArrayChildren; 如果是基础类型，则通过 createTextVNode 方法转换成 VNode 类型；否则就已经是 VNode 类型了，如果 children 是一个列表并且列表还存在嵌套的情况，则根据 nestedIndex 去更新它的 key。")]),e._v(" "),t("li",[e._v("经过对 children 的规范化，children 变成了一个类型为 VNode 的 Array。")])]),e._v(" "),t("h4",{attrs:{id:"总结："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结："}},[e._v("#")]),e._v(" 总结：")]),e._v(" "),t("blockquote",[t("p",[e._v("createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。\n回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的，接下来分析一下这个过程。")])]),e._v(" "),t("h3",{attrs:{id:"update"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[e._v("#")]),e._v(" update")]),e._v(" "),t("p",[e._v("Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；")]),e._v(" "),t("p",[e._v("这一章节只分析首次渲染部分。_update 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 "),t("code",[e._v("src/core/instance/lifecycle.js")]),e._v(" 中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n  // ...\n  \n  if (!prevVnode) {\n    // initial render\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n  } else {\n    // updates\n    vm.$el = vm.__patch__(prevVnode, vnode)\n  }\n  \n  //...\n  \n}\n\n")])])]),t("p",[t("code",[e._v("_update")]),e._v("的核心就是调用"),t("code",[e._v("vm.__patch__")]),e._v(" 方法，该方法实际上在不同的平台，比如 web 和 weex 上的定义不同，在 web 平台中它的定义在 src/platforms/web/runtime/index.js 中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype.__patch__ = inBrowser ? patch : noop\n")])])]),t("p",[e._v("在web平台上，服务端渲染没有真实的浏览器DOM环境，不需要把VNode转换成DOM，所以是一个空函数。在浏览器渲染中，指向了patch方法，他的定义在"),t("code",[e._v("src/platforms/web/runtime/patch.js")]),e._v("中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import * as nodeOps from 'web/runtime/node-ops'\n//...\n\nconst modules = platformModules.concat(baseModules)\n\n//通过函数科里化，先把差异磨平\nexport const patch: Function = createPatchFunction({ nodeOps, modules })\n")])])]),t("p",[e._v("该方法的定义是调用 "),t("code",[e._v("createPatchFunction")]),e._v(" 方法的返回值，这里传入了一个对象，包含 "),t("code",[e._v("nodeOps")]),e._v(" 参数和 "),t("code",[e._v("modules")]),e._v(" 参数。 createPatchFunction 的实现，定义在"),t("code",[e._v("src/core/vdom/patch.js")]),e._v("中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const hooks = ['create', 'activate', 'update', 'remove', 'destroy']\n\nexport function createPatchFunction (backend) {\n  let i, j\n  const cbs = {}\n\n  const { modules, nodeOps } = backend\n  \n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = []\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]])\n      }\n    }\n  }\n\n  // ...\n  /*  返回一个path方法，差异化已经磨平 */\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n      return\n    }\n\n    let isInitialPatch = false\n    const insertedVnodeQueue = []\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true\n      createElm(vnode, insertedVnodeQueue)\n    } else {\n      const isRealElement = isDef(oldVnode.nodeType)\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n      } else {\n        if (isRealElement) {//是否真实的dom节点\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR)\n            hydrating = true\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true)\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              )\n            }\n          }\n         //通过 emptyNodeAt 方法把 oldVnode 转换成 VNode 对象\n          oldVnode = emptyNodeAt(oldVnode)\n        }\n\n        // 替换当前的节点\n        const oldElm = oldVnode.elm\n        const parentElm = nodeOps.parentNode(oldElm)\n\n        // 调用 createElm 方法 create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        )\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          let ancestor = vnode.parent\n          const patchable = isPatchable(vnode)\n          while (ancestor) {\n            for (let i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor)\n            }\n            ancestor.elm = vnode.elm\n            if (patchable) {\n              for (let i = 0; i < cbs.create.length; ++i) {\n                cbs.create[i](emptyNode, ancestor)\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              const insert = ancestor.data.hook.insert\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (let i = 1; i < insert.fns.length; i++) {\n                  insert.fns[i]()\n                }\n              }\n            } else {\n              registerRef(ancestor)\n            }\n            ancestor = ancestor.parent\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0)\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode)\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n    return vnode.elm\n  }\n}\n")])])]),t("p",[e._v("这里用到了一"),t("strong",[e._v("个函数柯里化")]),e._v("的技巧，通过 "),t("code",[e._v("createPatchFunction")]),e._v(" 把差异化参数提前固化，这样不用每次调用 "),t("code",[e._v("patch")]),e._v(" 的时候都传递 "),t("code",[e._v("nodeOps")]),e._v(" 和 "),t("code",[e._v("modules")]),e._v(" 了，这种编程技巧也非常值得学习。")]),e._v(" "),t("p",[e._v("回到"),t("code",[e._v("patch")]),e._v("方法本身，它接收 4个参数:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("oldVnode")]),e._v(" 表示旧的 "),t("code",[e._v("VNode")]),e._v(" 节点，它也可以不存在或者是一个 "),t("code",[e._v("DOM")]),e._v(" 对象；")]),e._v(" "),t("li",[t("code",[e._v("vnode")]),e._v(" 表示执行 "),t("code",[e._v("_render")]),e._v(" 后返回的"),t("code",[e._v("VNode")]),e._v(" 的节点；")]),e._v(" "),t("li",[t("code",[e._v("hydrating")]),e._v(" 表示是否是服务端渲染；")]),e._v(" "),t("li",[t("code",[e._v("removeOnly")]),e._v(" 是给 "),t("code",[e._v("transition-group")]),e._v(" 用的，之后会介绍。")])]),e._v(" "),t("blockquote",[t("p",[e._v("createPatchFunction 内部定义了一系列的辅助方法，最终返回了一个 patch 方法，这个方法就赋值给了 vm._update 函数里调用的 vm."),t("strong",[e._v("patch")]),e._v("。")])]),e._v(" "),t("h2",{attrs:{id:"组件化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[e._v("#")]),e._v(" 组件化")]),e._v(" "),t("h3",{attrs:{id:"createcomponent"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#createcomponent"}},[e._v("#")]),e._v(" createComponent")]),e._v(" "),t("p",[e._v("上一章我们在分析 createElement 的实现的时候，它最终会调用 _createElement 方法，其中有一段逻辑是对参数 tag 的判断，如果是一个普通的 html 标签，像上一章的例子那样是一个普通的 div，则会实例化一个普通 VNode 节点，否则通过 createComponent 方法创建一个组件 VNode。\n"),t("code",[e._v("src/core/vdom/create-element.js")]),e._v("中的"),t("code",[e._v("_createElement")]),e._v("方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function _createElement(){\n    //...\n    if (typeof tag === 'string') {\n      //...\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children)\n    }\n}\n")])])]),t("p",[e._v("这一章传入的是一个 "),t("code",[e._v("App")]),e._v(" 对象，它本质上是一个 "),t("code",[e._v("Component")]),e._v(" 类型，那么它会走到上述代码的 "),t("code",[e._v("else")]),e._v("逻辑，直接通过 "),t("code",[e._v("createComponent")]),e._v(" 方法来创建 "),t("code",[e._v("vnode")]),e._v("。它定义在 "),t("code",[e._v("src/core/vdom/create-component.js")]),e._v(" 文件中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function createComponent (\n  Ctor: Class<Component> | Function | Object | void,\n  data: ?VNodeData,\n  context: Component,\n  children: ?Array<VNode>,\n  tag?: string\n): VNode | Array<VNode> | void {\n  //...\n  \n  //1、构造子类构造函数\n  const baseCtor = context.$options._base\n\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor)//baseCtor 实际上就是 Vue\n  }\n\n  //...\n\n  //2、安装钩子函数\n  installComponentHooks(data)\n\n  //3、实例化 VNode\n  const name = Ctor.options.name || tag\n  const vnode = new VNode(\n    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,\n    data, undefined, undefined, undefined, context,\n    { Ctor, propsData, listeners, tag, children },\n    asyncFactory\n  )\n\n  //...\n\n  return vnode\n}\n")])])]),t("h4",{attrs:{id:"构造子类构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造子类构造函数"}},[e._v("#")]),e._v(" 构造子类构造函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" //1、构造子类构造函数\n  const baseCtor = context.$options._base\n\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor)//baseCtor 实际上就是 Vue\n  }\n")])])]),t("p",[e._v("这一步有2个地方要注意")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("baseCtor")]),e._v(" 实际上就是 "),t("code",[e._v("Vue")]),e._v("，这个的定义是在最开始初始化 "),t("code",[e._v("Vue")]),e._v(" 的阶段定义了"),t("code",[e._v("Vue.options._base = Vue")]),e._v(",在"),t("code",[e._v("_init")]),e._v(" 函数中通过"),t("code",[e._v("mergeOptions")]),e._v("把 "),t("code",[e._v("Vue")]),e._v(" 上的一些"),t("code",[e._v("option")]),e._v(" 扩展到了"),t("code",[e._v("vm.$options")]),e._v("上，所以我们也就能通过 "),t("code",[e._v("vm.$options._base")]),e._v("拿到 "),t("code",[e._v("Vue")]),e._v(" 这个构造函数了。")]),e._v(" "),t("li",[t("code",[e._v("Vue.extend")]),e._v(" 的作用就是构造一个 "),t("code",[e._v("Vue")]),e._v(" 的子类，它使用一种非常经典的"),t("code",[e._v("原型继承")]),e._v("的方式把一个纯对象转换一个继承于 "),t("code",[e._v("Vue")]),e._v(" 的构造器"),t("code",[e._v("Sub")]),e._v(" 并返回，然后对 "),t("code",[e._v("Sub")]),e._v(" 这个对象本身扩展了一些属性，如扩展 "),t("code",[e._v("options")]),e._v("、添加全局 API 等；并且对配置中的 "),t("code",[e._v("props")]),e._v(" 和 "),t("code",[e._v("computed")]),e._v(" 做了初始化工作；最后对于这个 Sub 构造函数做了缓存，避免多次执行 Vue.extend 的时候对同一个子组件重复构造。")])]),e._v(" "),t("p",[e._v("我们来看一下"),t("code",[e._v("Vue.extend")]),e._v("函数的定义，在 "),t("code",[e._v("src/core/global-api/extend.js")]),e._v("中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.extend = function (extendOptions: Object): Function {\n  extendOptions = extendOptions || {}\n  const Super = this\n  const SuperId = Super.cid\n  const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})\n  \n  //避免重复构造\n  if (cachedCtors[SuperId]) {\n    return cachedCtors[SuperId]\n  }\n\n  //通过原型继承\n  Sub.prototype = Object.create(Super.prototype)\n  Sub.prototype.constructor = Sub\n  Sub.cid = cid++\n  //扩展options\n  Sub.options = mergeOptions(\n    Super.options,\n    extendOptions\n  )\n  Sub['super'] = Super\n\n  if (Sub.options.props) {//初始化props\n    initProps(Sub)\n  }\n  if (Sub.options.computed) {//初始化computed\n    initComputed(Sub)\n  }\n  //...\n\n  // cache constructor\n  cachedCtors[SuperId] = Sub  //缓存构造函数\n  return Sub\n}\n")])])]),t("h4",{attrs:{id:"安装组件钩子函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装组件钩子函数"}},[e._v("#")]),e._v(" 安装组件钩子函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// install component management hooks onto the placeholder node\ninstallComponentHooks(data)\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const hooksToMerge = Object.keys(componentVNodeHooks) //当前组件的生命周期钩子\n\nfunction installComponentHooks (data: VNodeData) {\nconst componentVNodeHooks = {\n   //init在patch的时候会用到\n  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      const mountedNode: any = vnode // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode)\n    } else {\n      const child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      )\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating)\n    }\n  },\n\n}\n\n//...\n  const hooks = data.hook || (data.hook = {})\n  for (let i = 0; i < hooksToMerge.length; i++) {//循环组件的钩子数组\n    const key = hooksToMerge[i]\n    const existing = hooks[key] //以有的钩子\n    const toMerge = componentVNodeHooks[key] //组件的钩子\n    if (existing !== toMerge && !(existing && existing._merged)) {//合并钩子\n      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge\n    }\n  }\n  \n  //...\n}\n")])])]),t("p",[e._v("整个 "),t("code",[e._v("installComponentHooks")]),e._v(" 的过程就是把 "),t("code",[e._v("componentVNodeHooks")]),e._v(" 的钩子函数合并到 "),t("code",[e._v("data.hook")]),e._v(" 中，在 "),t("code",[e._v("VNode")]),e._v(" 执行 "),t("code",[e._v("patch")]),e._v(" 的过程中执行相关的钩子函数，具体的执行我们稍后在介绍 "),t("code",[e._v("patch")]),e._v(" 过程中会详细介绍。这里要注意的是合并策略，在合并过程中，如果某个时机的钩子已经存在 "),t("code",[e._v("data.hook")]),e._v(" 中，那么通过执行 "),t("code",[e._v("mergeHook")]),e._v(" 函数做合并，这个逻辑很简单，就是在最终执行的时候，依次执行这两个钩子函数即可。")]),e._v(" "),t("h4",{attrs:{id:"实例化-vnode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例化-vnode"}},[e._v("#")]),e._v(" 实例化 VNode")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const name = Ctor.options.name || tag\nconst vnode = new VNode(\n  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,\n  data, undefined, undefined, undefined, context,\n  { Ctor, propsData, listeners, tag, children },\n  asyncFactory\n)\nreturn vnode\n")])])]),t("p",[e._v("通过 "),t("code",[e._v("new VNode")]),e._v(" 实例化一个 "),t("code",[e._v("vnode")]),e._v(" 并返回。需要注意的是和普通元素节点的"),t("code",[e._v("vnode")]),e._v(" 不同，组件的 "),t("code",[e._v("vnode")]),e._v("是没有"),t("code",[e._v("children")]),e._v("的，这点很关键，在之后的"),t("code",[e._v("patch")]),e._v(" 过程中我们会再提。")]),e._v(" "),t("p",[e._v("总结：")]),e._v(" "),t("blockquote",[t("p",[e._v("在渲染一个组件的时候的 3 个关键逻辑：构造子类构造函数，安装组件钩子函数和实例化 "),t("code",[e._v("vnode")]),e._v("。"),t("code",[e._v("createComponent")]),e._v(" 后返回的是组件 "),t("code",[e._v("vnode")]),e._v("，它也一样走到 vm._update 方法，进而执行了 "),t("code",[e._v("patch")]),e._v(" 函数，")])]),e._v(" "),t("h3",{attrs:{id:"patch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#patch"}},[e._v("#")]),e._v(" patch")]),e._v(" "),t("p",[e._v("patch 的过程会调用 createElm 创建元素节点\n它的定义在 "),t("code",[e._v("src/core/vdom/patch.js")]),e._v(" 中")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function createElm (\n  vnode,\n  insertedVnodeQueue,\n  parentElm,\n  refElm,\n  nested,\n  ownerArray,\n  index\n) {\n  // ...\n  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n    return\n  }\n  // ...\n}\n")])])]),t("p",[e._v("这里会判断 "),t("code",[e._v("createComponent(vnode, insertedVnodeQueue, parentElm, refElm)")]),e._v("的返回值，如果为 true 则直接结束，那么接下来看一下 createComponent 方法的实现：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i = vnode.data\n  if (isDef(i)) {\n    //...\n    if (isDef(i = i.hook) && isDef(i = i.init)) {\n      i(vnode, false /* hydrating */)\n    }\n    //...\n    if (isDef(vnode.componentInstance)) {\n      initComponent(vnode, insertedVnodeQueue)\n      insert(parentElm, vnode.elm, refElm)\n      if (isTrue(isReactivated)) {\n        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\n      }\n      return true\n    }\n  }\n}\n")])])]),t("p",[e._v("如果 vnode 是一个组件 VNode，那么条件会满足，并且得到 i 就是 init 钩子函数，回顾上节我们在创建组件 VNode 的时候合并钩子函数中就包含 init 钩子函数，定义在 src/core/vdom/create-component.js 中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("init (vnode: VNodeWithData, hydrating: boolean): ?boolean {\n  if (\n    vnode.componentInstance &&\n    !vnode.componentInstance._isDestroyed &&\n    vnode.data.keepAlive\n  ) {\n    //...\n  } else {\n  //创建一个vue实例\n    const child = vnode.componentInstance = createComponentInstanceForVnode(\n      vnode,\n      activeInstance\n    )\n    //挂载子组件\n    child.$mount(hydrating ? vnode.elm : undefined, hydrating)\n  }\n},\n")])])]),t("p",[e._v("init 钩子函数执行也很简单，它是通过 "),t("code",[e._v("createComponentInstanceForVnode")]),e._v("创建一个"),t("code",[e._v("Vue")]),e._v(" 的实例，然后调用"),t("code",[e._v("$mount")]),e._v("方法挂载子组件， 先来看一下 "),t("code",[e._v("createComponentInstanceForVnode")]),e._v("的实现：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function createComponentInstanceForVnode (\n  vnode: any, // we know it's MountedComponentVNode but flow doesn't\n  parent: any, // activeInstance in lifecycle state\n): Component {\n  const options: InternalComponentOptions = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent\n  }\n  // check inline-template render functions\n  const inlineTemplate = vnode.data.inlineTemplate\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render\n    options.staticRenderFns = inlineTemplate.staticRenderFns\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n")])])]),t("p",[t("code",[e._v("createComponentInstanceForVnode")]),e._v(" 函数构造的一个内部组件的参数，然后执行 "),t("code",[e._v("new vnode.componentOptions.Ctor(options)")]),e._v("。这里的 "),t("code",[e._v("vnode.componentOptions.Ctor")]),e._v(" 对应的就是子组件的构造函数，我们上一节分析了它实际上是继承于 "),t("code",[e._v("Vue")]),e._v(" 的一个构造器 "),t("code",[e._v("Sub")]),e._v("，相当于 "),t("code",[e._v("new Sub(options)")]),e._v(" 这里有几个关键参数要注意几个点，"),t("code",[e._v("_isComponent")]),e._v("为 "),t("code",[e._v("true")]),e._v(" 表示它是一个组件，"),t("code",[e._v("parent")]),e._v(" 表示当前激活的组件实例。")]),e._v(" "),t("p",[e._v("所以子组件的实例化实际上就是在这个时机执行的，并且它会执行实例的"),t("code",[e._v("_init")]),e._v(" 方法，这个过程有一些和之前不同的地方需要挑出来说，代码在 src/core/instance/init.js 中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype._init = function (options?: Object) {\n  const vm: Component = this\n  // 合并options\n  if (options && options._isComponent) {\n     //组件走到这里\n    initInternalComponent(vm, options)\n  } else {\n    //...\n  }\n  // ...\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  } \n}\n")])])]),t("p",[e._v("这里首先是合并 options 的过程有变化，"),t("code",[e._v("_isComponent")]),e._v(" 为 true，所以走到了 "),t("code",[e._v("initInternalComponent")]),e._v(" 过程，这个函数的实现也简单看一下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function initInternalComponent (vm: Component, options: InternalComponentOptions) {\n  const opts = vm.$options = Object.create(vm.constructor.options)\n  // doing this because it's faster than dynamic enumeration.\n  const parentVnode = options._parentVnode\n  opts.parent = options.parent  //合并\n  opts._parentVnode = parentVnode  //合并\n\n  const vnodeComponentOptions = parentVnode.componentOptions\n  opts.propsData = vnodeComponentOptions.propsData\n  opts._parentListeners = vnodeComponentOptions.listeners\n  opts._renderChildren = vnodeComponentOptions.children\n  opts._componentTag = vnodeComponentOptions.tag\n\n  if (options.render) {\n    opts.render = options.render\n    opts.staticRenderFns = options.staticRenderFns\n  }\n}\n")])])]),t("p",[e._v("这个过程我们重点记住以下几个点即可："),t("code",[e._v("opts.parent = options.parent、opts._parentVnode = parentVnode")]),e._v("，它们是把之前我们通过 "),t("code",[e._v("createComponentInstanceForVnode")]),e._v(" 函数传入的几个参数合并到内部的选项 $options 里了。")]),e._v(" "),t("p",[e._v("再来看一下 _init 函数最后执行的代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (vm.$options.el) {\n   vm.$mount(vm.$options.el)\n}\n")])])]),t("p",[e._v("由于组件初始化的时候是不传"),t("code",[e._v("el")]),e._v(" 的，因此组件是自己接管了 $mount 的过程，这个过程的主要流程在上一章介绍过了，回到组件 "),t("code",[e._v("init")]),e._v(" 的过程"),t("code",[e._v("，componentVNodeHooks")]),e._v(" 的 "),t("code",[e._v("init")]),e._v(" 钩子函数，在完成实例化的 "),t("code",[e._v("_init")]),e._v(" 后，接着会执行 "),t("code",[e._v("child.$mount(hydrating ? vnode.elm : undefined, hydrating)")]),e._v(" 。这里 "),t("code",[e._v("hydrating")]),e._v("为 "),t("code",[e._v("true")]),e._v(" 一般是服务端渲染的情况，我们只考虑客户端渲染，所以这里 "),t("code",[e._v("$mount")]),e._v(" 相当于执行"),t("code",[e._v("child.$mount(undefined, false)")]),e._v("，它最终会调用 "),t("code",[e._v("mountComponent")]),e._v("方法，进而执行 "),t("code",[e._v("vm._render()")]),e._v("方法：")]),e._v(" "),t("h5",{attrs:{id:"执行-vm-render-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行-vm-render-方法"}},[e._v("#")]),e._v(" 执行 "),t("code",[e._v("vm._render()")]),e._v("方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype._render = function (): VNode {\n  const vm: Component = this\n  const { render, _parentVnode } = vm.$options\n\n  vm.$vnode = _parentVnode\n \n  let vnode\n  try {\n    vnode = render.call(vm._renderProxy, vm.$createElement)\n  } catch (e) {\n    // ...\n  }\n //关键步骤，设置父子关系\n  vnode.parent = _parentVnode\n  return vnode\n}\n")])])]),t("p",[t("code",[e._v("render")]),e._v(" 函数生成的 "),t("code",[e._v("vnode")]),e._v(" 的 "),t("code",[e._v("parent")]),e._v(" 指向了 "),t("code",[e._v("_parentVnode")]),e._v("。")]),e._v(" "),t("h5",{attrs:{id:"执行-vm-update-去渲染vnode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行-vm-update-去渲染vnode"}},[e._v("#")]),e._v(" 执行 "),t("code",[e._v("vm._update")]),e._v(" 去渲染"),t("code",[e._v("VNode")])]),e._v(" "),t("p",[e._v("了。来看一下组件渲染的过程中有哪些需要注意的，"),t("code",[e._v("vm._update")]),e._v(" 的定义在 "),t("code",[e._v("src/core/instance/lifecycle.js")]),e._v("中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export let activeInstance: any = null\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n  const vm: Component = this\n  const prevEl = vm.$el\n  const prevVnode = vm._vnode\n  const prevActiveInstance = activeInstance\n  activeInstance = vm\n  vm._vnode = vnode //1、这个 vnode 是通过 vm._render() 返回的组件渲染 VNode\n\n  if (!prevVnode) {\n    // initial render\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n  } else {\n    // updates\n    vm.$el = vm.__patch__(prevVnode, vnode)\n  }\n  activeInstance = prevActiveInstance\n  // update __vue__ reference\n  if (prevEl) {\n    prevEl.__vue__ = null\n  }\n  if (vm.$el) {\n    vm.$el.__vue__ = vm\n  }\n  // if parent is an HOC, update its $el as well\n  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n    vm.$parent.$el = vm.$el\n  }\n  // updated hook is called by the scheduler to ensure that children are\n  // updated in a parent's updated hook.\n}\n")])])]),t("ol",[t("li",[t("code",[e._v("vm._vnode = vnode")]),e._v("的逻辑，这个 "),t("code",[e._v("vnode")]),e._v(" 是通过"),t("code",[e._v("vm._render()")]),e._v("返回的组件渲染 "),t("code",[e._v("VNode")]),e._v("，"),t("code",[e._v("vm._vnode")]),e._v(" 和 "),t("code",[e._v("vm.$vnode")]),e._v(" 的关系就是一种父子关系，用代码表达就是 "),t("code",[e._v("vm._vnode.parent === vm.$vnode")]),e._v("。")]),e._v(" "),t("li",[e._v("这个"),t("code",[e._v("activeInstance")]),e._v("作用就是保持当前上下文的 Vue 实例，它是在"),t("code",[e._v("lifecycle")]),e._v("模块的全局变量，定义是 "),t("code",[e._v("export let activeInstance: any = null")]),e._v("，并且在之前我们调用 "),t("code",[e._v("createComponentInstanceForVnode")]),e._v("方法的时候从 "),t("code",[e._v("lifecycle")]),e._v(" 模块获取，并且作为参数传入的。")]),e._v(" "),t("li",[e._v("在 "),t("code",[e._v("vm._update")]),e._v("的过程中，把当前的 vm 赋值给 "),t("code",[e._v("activeInstance")]),e._v("，同时通过 "),t("code",[e._v("const prevActiveInstance = activeInstance")]),e._v(" 用 "),t("code",[e._v("prevActiveInstance")]),e._v("保留上一次的 "),t("code",[e._v("activeInstance")]),e._v("。实际上，"),t("code",[e._v("prevActiveInstance")]),e._v(" 和当前的 vm 是一个父子关系，当一个 vm 实例完成它的所有子树的 patch 或者 update 过程后，activeInstance 会回到它的父实例，这样就完美地保证了 "),t("code",[e._v("createComponentInstanceForVnode")]),e._v(" 整个深度遍历过程中，我们在实例化子组件的时候能传入当前子组件的父 Vue 实例，并在"),t("code",[e._v("_init")]),e._v("的过程中，通过 "),t("code",[e._v("vm.$parent")]),e._v(" 把这个父子关系保留。")]),e._v(" "),t("li",[e._v("最后就是调用 "),t("strong",[e._v("patch")]),e._v(" 渲染 VNode")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n \nfunction patch (oldVnode, vnode, hydrating, removeOnly) {\n  // ...\n  let isInitialPatch = false\n  const insertedVnodeQueue = []\n\n  if (isUndef(oldVnode)) {\n    // empty mount (likely as component), create new root element\n    isInitialPatch = true\n    createElm(vnode, insertedVnodeQueue)\n  } else {\n    // ...\n  }\n  // ...\n}\n")])])]),t("p",[e._v("注意，这里我们传入的 vnode 是组件渲染的 vnode，也就是我们之前说的 "),t("code",[e._v("vm._vnode")]),e._v("，如果组件的根节点是个普通元素，那么"),t("code",[e._v("vm._vnode")]),e._v(" 也是普通的 vnode，这里 "),t("code",[e._v("createComponent(vnode, insertedVnodeQueue, parentElm, refElm)")]),e._v(" 的返回值是 false。接下来的过程就和我们上一章一样了，先创建一个父节点占位符，然后再遍历所有子 VNode 递归调用 createElm，在遍历的过程中，如果遇到子 VNode 是一个组件的 VNode，则重复本节开始的过程，这样通过一个递归的方式就可以完整地构建了整个组件树。在完成组件的整个 patch 过程后，最后执行 insert(parentElm, vnode.elm, refElm) 完成组件的 DOM 插入，如果组件 patch 过程中又创建了子组件，那么DOM 的插入顺序是先子后父。")]),e._v(" "),t("p",[e._v("总结：")]),e._v(" "),t("blockquote",[t("p",[e._v("那么到此，一个组件的 VNode 是如何创建、初始化、渲染的过程也就介绍完毕了。在对组件化的实现有一个大概了解后，接下来我们来介绍一下这其中的一些细节。我们知道编写一个组件实际上是编写一个 JavaScript 对象，对象的描述就是各种配置，之前我们提到在 _init 的最初阶段执行的就是 merge options 的逻辑。")])]),e._v(" "),t("h3",{attrs:{id:"合并配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合并配置"}},[e._v("#")]),e._v(" 合并配置")]),e._v(" "),t("p",[t("code",[e._v("new Vue")]),e._v("的过程通常有 2 种场景，一种是外部我们的代码主动调用"),t("code",[e._v("new Vue(options)")]),e._v(" 的方式实例化一个 "),t("code",[e._v("Vue")]),e._v(" 对象；另一种是我们上一节分析的组件过程中内部通过 "),t("code",[e._v("new Vue(options)")]),e._v("实例化子组件。\n无论哪种场景，都会执行实例的"),t("code",[e._v("_init(options)")]),e._v(" 方法，它首先会执行一个"),t("code",[e._v("merge options")]),e._v("的逻辑，相关的代码在 "),t("code",[e._v("src/core/instance/init.js")]),e._v(" 中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype._init = function (options?: Object) {\n  // merge options\n  if (options && options._isComponent) {\n    initInternalComponent(vm, options)\n  } else {\n    vm.$options = mergeOptions(\n      resolveConstructorOptions(vm.constructor),\n      options || {},\n      vm\n    )\n  }\n  // ...\n}\n")])])]),t("h4",{attrs:{id:"外部调用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#外部调用场景"}},[e._v("#")]),e._v(" 外部调用场景")]),e._v(" "),t("p",[e._v("当执行 new Vue 的时候，在执行 this._init(options) 的时候，就会执行如下逻辑去合并 options：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vm.$options = mergeOptions(\n  resolveConstructorOptions(vm.constructor),\n  options || {},\n  vm\n)\n")])])]),t("p",[e._v("这里通过调用"),t("code",[e._v("mergeOptions")]),e._v("方法来合并，它实际上就是把 "),t("code",[e._v("resolveConstructorOptions(vm.constructor)")]),e._v("的返回值和 "),t("code",[e._v("options")]),e._v("做合并，"),t("code",[e._v("resolveConstructorOptions")]),e._v(" 的实现先不考虑，在我们这个场景下，它还是简单返回 "),t("code",[e._v("vm.constructor.options")]),e._v("，相当于 "),t("code",[e._v("Vue.options")]),e._v("。")]),e._v(" "),t("p",[e._v("那么回到"),t("code",[e._v("mergeOptions")]),e._v("这个函数，它的定义在 "),t("code",[e._v("src/core/util/options.js")]),e._v("中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nexport function mergeOptions (\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object {\n  //...\n  normalizeProps(child, vm)\n  normalizeInject(child, vm)\n  normalizeDirectives(child)\n  const extendsFrom = child.extends\n  if (extendsFrom) {//1、递归把extends合并到parent上\n    parent = mergeOptions(parent, extendsFrom, vm)\n  }\n  if (child.mixins) {//2、递归把mixins合并到parent上\n    for (let i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm)\n    }\n  }\n  const options = {}\n  let key\n  for (key in parent) {//3、遍历parent，调用mergeField\n    mergeField(key)\n  }\n  for (key in child) {//4、遍历child，如果key不在parent的自身属性上，调用mergefield\n    if (!hasOwn(parent, key)) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n}\n")])])]),t("p",[e._v("mergeOptions 主要功能就是把 parent 和 child 这两个对象根据一些合并策略，合并成一个新对象并返回。比较核心的几步：")]),e._v(" "),t("ol",[t("li",[e._v("先递归把 extends 和 mixins 合并到 parent 上。")]),e._v(" "),t("li",[e._v("遍历 parent，调用 mergeField。")]),e._v(" "),t("li",[e._v("遍历 child，如果 key 不在 parent 的自身属性上，则调用 mergeField。")])]),e._v(" "),t("p",[e._v("mergeField 函数合并策略")]),e._v(" "),t("p",[e._v("mergeOptions 函数，一旦 parent 和 child都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。")]),e._v(" "),t("h4",{attrs:{id:"组件场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件场景"}},[e._v("#")]),e._v(" 组件场景")]),e._v(" "),t("p",[e._v("组件的构造函数是通过 Vue.extend 继承自 Vue 的，先回顾一下这个过程，代码定义在 src/core/global-api/extend.js 中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.extend = function (extendOptions: Object): Function {\n  // ...\n  Sub.options = mergeOptions(\n    Super.options,  //Vue.options\n    extendOptions  //前面定义的组件对象\n  )\n  //...\n  Sub.superOptions = Super.options\n  Sub.extendOptions = extendOptions\n  Sub.sealedOptions = extend({}, Sub.options)\n\n  // ...\n  return Sub\n}\n")])])]),t("p",[e._v("总结：")]),e._v(" "),t("blockquote",[t("p",[e._v("我们需要知道对于 options 的合并有 2 种方式，子组件初始化过程通过 initInternalComponent 方式要")])]),e._v(" "),t("h2",{attrs:{id:"深入响应式原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深入响应式原理"}},[e._v("#")]),e._v(" 深入响应式原理")]),e._v(" "),t("p",[e._v("参考文章")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://ustbhuangyi.github.io/vue-analysis/",target:"_blank",rel:"noopener noreferrer"}},[e._v("黄轶vue源码文档"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=a.exports}}]);