(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{364:function(t,a,_){"use strict";_.r(a);var v=_(42),e=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),_("h2",{attrs:{id:"浏览器缓存类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存类型"}},[t._v("#")]),t._v(" 浏览器缓存类型")]),t._v(" "),_("ol",[_("li",[t._v("强缓存：浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的Cache-Control和Expires来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次==请求不会与服务器进行通信==。返回状态码 200 (from memory cache)或200 (from disk cache)。")]),t._v(" "),_("li",[t._v("协商缓存：==向服务器发送请求==，服务器会根据这个请求的参数判断是否命中缓存。如果命中缓存，则返回304状态码并带上新的header通知浏览器从缓存中读取资源。")])]),t._v(" "),_("h2",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),_("h3",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache-Control")]),t._v(" "),_("p",[t._v("==Cache-Control是 http1.1 时出现的header信息==，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。")]),t._v(" "),_("p",[t._v("几个常用值")]),t._v(" "),_("ul",[_("li",[t._v("max-age（单位为s）指定设置缓存最大的有效时间，定义的是时间长短")]),t._v(" "),_("li",[t._v("no-cache 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而==是在缓存前要向服务器确认资源是否被更改==。如果浏览器返回304，那么就还是会取浏览器上的缓存。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。")]),t._v(" "),_("li",[t._v("no-store 绝对禁止缓存。每次请求资源都要从服务器重新获取")])]),t._v(" "),_("h3",{attrs:{id:"expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),_("p",[t._v("==Expires是http1.0的规==范，它的值是==一个绝对时间的GMT格式的时间字符串==。比如 ：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，==只要发送请求时间是在Expires之前，那么本地缓存始终有效==，则在缓存中读取数据。缺点：==当服务器与客户端时间偏差较大时，就会导致缓存混乱==。")]),t._v(" "),_("p",[_("strong",[t._v("注意： Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),_("h3",{attrs:{id:"last-modify-if-modify-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modify-if-modify-since"}},[t._v("#")]),t._v(" Last-Modify/If-Modify-Since")]),t._v(" "),_("p",[t._v("浏览器第一次请求一个资源的时候，"),_("strong",[t._v("服务器返回的header中会加上Last-Modify")]),t._v("，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。\n当浏览器再次请求该资源时，"),_("strong",[t._v("request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify")]),t._v("。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。\n如果命中缓存，则返回304，并且不会返回资源内容和Last-Modify。")]),t._v(" "),_("h3",{attrs:{id:"etag-if-none-match"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[t._v("#")]),t._v(" ETag/If-None-Match")]),t._v(" "),_("p",[t._v("Etag/If-None-Match返回的是一个校验码（Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。\n与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，"),_("strong",[t._v("由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化")]),t._v("。")]),t._v(" "),_("p",[t._v("两者区别")]),t._v(" "),_("ol",[_("li",[t._v("在精度上，ETag优于Last-Modified。Last-Modified的单位是秒，如果某个文件在1秒内改变了很多次，那么Last-Modified无法体现。ETag每次都会改变。")]),t._v(" "),_("li",[t._v("性能上ETag逊于Last-Modified，ETag计算需要时间。")]),t._v(" "),_("li",[t._v("优先级上，服务器优先考虑ETag。")])]),t._v(" "),_("p",[_("strong",[t._v("注意： Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。")])]),t._v(" "),_("h2",{attrs:{id:"用户行为影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户行为影响"}},[t._v("#")]),t._v(" 用户行为影响")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("缓存类型")]),t._v(" "),_("th",[t._v("获取资源形式")]),t._v(" "),_("th",[t._v("状态码")]),t._v(" "),_("th",[t._v("发送请求到服务器")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("强缓存")]),t._v(" "),_("td",[t._v("从缓存取")]),t._v(" "),_("td",[t._v("200")]),t._v(" "),_("td",[t._v("否，直接从缓存取")])]),t._v(" "),_("tr",[_("td",[t._v("协商缓存")]),t._v(" "),_("td",[t._v("从缓存取")]),t._v(" "),_("td",[t._v("304")]),t._v(" "),_("td",[t._v("是，通过服务端判断是否命中缓存")])])])]),t._v(" "),_("h2",{attrs:{id:"用户行为对缓存的影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户行为对缓存的影响"}},[t._v("#")]),t._v(" 用户行为对缓存的影响")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("用户操作")]),t._v(" "),_("th",[t._v("强缓存")]),t._v(" "),_("th",[t._v("协商缓存")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("地址栏回车")]),t._v(" "),_("td",[t._v("有效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("页面链接跳转")]),t._v(" "),_("td",[t._v("有效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("新打开窗口")]),t._v(" "),_("td",[t._v("有效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("前进后退")]),t._v(" "),_("td",[t._v("有效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("F5刷新")]),t._v(" "),_("td",[t._v("无效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("Ctrl+F5强制刷新")]),t._v(" "),_("td",[t._v("无效")]),t._v(" "),_("td",[t._v("无效")])])])]),t._v(" "),_("p",[t._v("缓存机制优先级")]),t._v(" "),_("ul",[_("li",[t._v("Expires < Cache:max-age")]),t._v(" "),_("li",[t._v("Last-Modified < ETag")])]),t._v(" "),_("h2",{attrs:{id:"补充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[t._v("#")]),t._v(" 补充")]),t._v(" "),_("h3",{attrs:{id:"webkit的资源分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webkit的资源分类"}},[t._v("#")]),t._v(" webkit的资源分类")]),t._v(" "),_("ul",[_("li",[t._v("主资源：比==如HTML页面，或者下载项==，对应代码中的类是MainResourceLoader。可以认为是地址栏url对应的那个资源。")]),t._v(" "),_("li",[t._v("派生资源：比如HTML页面中==内嵌的图片或者脚本链接==(js,css)，对应代码中的类是SubresourceLoader。即主资源页面加载的其他资源。")])]),t._v(" "),_("h4",{attrs:{id:"_200-from-memory-cache"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_200-from-memory-cache"}},[t._v("#")]),t._v(" 200 (from memory cache)")]),t._v(" "),_("p",[t._v("不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当kill进程后，也就是浏览器关闭以后，数据将不存在。")]),t._v(" "),_("p",[t._v("==这种方式只适用于派生资源。== 也就是主HTML页面中内嵌页的其他资源，==比如css，js 等等。 不包括这个主页面==。")]),t._v(" "),_("h4",{attrs:{id:"_200-from-disk-cache"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_200-from-disk-cache"}},[t._v("#")]),t._v(" 200 (from disk cache)")]),t._v(" "),_("p",[t._v("不访问服务器，直接从磁盘中读取缓存，当kill进程时，数据还是存在\n==这种方式也只能缓存派生资源==。")]),t._v(" "),_("p",[t._v("举个例子就是：\n访问-> 200 -> 退出浏览器\n再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)")]),t._v(" "),_("p",[t._v("普通刷新会启用协商缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的， 因为直接访问是属于主资源的，这时候是不能用强缓存的，只能用协商缓存。")]),t._v(" "),_("p",[t._v("参考链接")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://kebingzao.com/2018/07/05/browser-cache/",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅谈之-浏览器缓存"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=e.exports}}]);