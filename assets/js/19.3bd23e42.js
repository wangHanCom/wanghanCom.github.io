(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{365:function(t,e,_){"use strict";_.r(e);var v=_(42),a=Object(v.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http协议"}},[t._v("#")]),t._v(" http协议")]),t._v(" "),_("p",[_("strong",[t._v("HTTP是不保存状态的协议")]),t._v("，既无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此"),_("strong",[t._v("连接双方不能知晓对方当前的身份和状态")]),t._v("。这也是Cookie技术产生的重要原因之一：客户端的状态管理。浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保持 Cookie。而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务端识别客户端身份状态的标识。")]),t._v(" "),_("h2",{attrs:{id:"http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" http")]),t._v(" "),_("h3",{attrs:{id:"tcp-ip协议族"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip协议族"}},[t._v("#")]),t._v(" tcp/IP协议族")]),t._v(" "),_("p",[t._v("TCP/IP 协议族是Internet最基本的协议，HTTP协议是它的一个子集。TCP/IP协议族按层次分为以下四层\n应用层、传输层、网络层、链路层、")]),t._v(" "),_("h3",{attrs:{id:"串行连接、持久连接、管道化持久连接、http-2-0多路复用简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#串行连接、持久连接、管道化持久连接、http-2-0多路复用简介"}},[t._v("#")]),t._v(" 串行连接、持久连接、管道化持久连接、http/2.0多路复用简介")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("串行连接")]),t._v("： HTTP有无连接的特性，即每次连接只能处理一个请求，收到响应后立即断开连接。HTTP/1.0 版本（称为串行连接或短连接、短轮询）中每次HTTP通信后都要断开TCP连接，所以每个新的HTTP请求都需要建立一个新的连接。并且每次请求都建立新的tcp连接（每次都有三次握手四次挥别）极大的增加了通信开销。==总结：串行连接每次发起请求都必须建立新的tcp连接。==")]),t._v(" "),_("li",[_("strong",[t._v("持久连接")]),t._v("： 为解决这个问题，有人提出了持久连接（也叫长连接、长轮询）。一定时间内，"),_("strong",[t._v("同一域名下的HTTP请求，只要两端都没有提出断开连接，则持久保持TCP连接状态")]),t._v("，其他请求可以复用这个连接通道。"),_("strong",[t._v("HTTP/1.1 实现并默认了所有连接都是持久连接")]),t._v("，这样客户端发起多个HTTP请求时就减少了TCP握手造成的网络资源和通信时间的浪费。==但是持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起==。==总结：持久连接多个http请求可以复用同一个tcp连接，但是下次请求必须在上次响应返回之后进行。==")]),t._v(" "),_("li",[_("strong",[t._v("管道化持久连接")]),t._v("： 管道化则可以不用等待响应返回而发送下个==请求并按顺序返回响应==，现代浏览器并未默认开启管道化。==总结：管道化持久连接也可以复用同一个tcp连接，并且可以不用等待发出多个http请求，但是响应必须按顺序返回==。")]),t._v(" "),_("li",[_("strong",[t._v("HTTP/2.0多路复用")]),t._v("： 每个HTTP请求都有一个序列标识符，这样浏览器可以==并发多个请求==，服务器接收到数据后，再==根据序列标识符重新排序成不同的请求报文，而不会导致数据错乱==。同样，服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文。并且==同一个域名下的所有请求都复用同一个TCP连接，极大增加了服务器处理并发的上限==。")]),t._v(" "),_("li",[_("strong",[t._v("WebSocket")]),t._v("： WebSocket是HTML5提出的一种==客户端和服务端通讯的全双工协议==，由客户端发起请求，建立连接之后不仅客户端可以主动向服务端发送请求，==服务端可以主动向客户端推送信息==。")])]),t._v(" "),_("p",[t._v("疑问：管道持久化和多路复用有什么区别？？？")]),t._v(" "),_("h2",{attrs:{id:"http1-0-2-0区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-0-2-0区别"}},[t._v("#")]),t._v(" http1.0/2.0区别")]),t._v(" "),_("h3",{attrs:{id:"http-1-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[t._v("#")]),t._v(" HTTP/1.0")]),t._v(" "),_("p",[t._v("最早的http只是使用在一些较为简单的网页上和网络请求上，所以比较简单，"),_("strong",[t._v("每次请求都打开一个新的TCP链接，收到响应之后立即断开连接")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"http-1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" HTTP/1.1")]),t._v(" "),_("ul",[_("li",[t._v("HTTP/1.1 引入了更多的==缓存控制策略==，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等")]),t._v(" "),_("li",[t._v("HTTP/1.1 允许范围请求，即在请求头中加入==Range==头部")]),t._v(" "),_("li",[t._v("HTTP/1.1 的请求消息和响应消息都必须包含==Host==头部，以区分同一个物理主机中的不同虚拟主机的域名")]),t._v(" "),_("li",[t._v("HTTP/1.1 ==默认开启持久连接==，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。")])]),t._v(" "),_("p",[t._v("补充：")]),t._v(" "),_("ul",[_("li",[t._v("长连接：一个tcp/ip连接上可以连续发送多个数据包")])]),t._v(" "),_("h3",{attrs:{id:"http-2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[t._v("#")]),t._v(" HTTP/2.0")]),t._v(" "),_("p",[t._v("在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。\n帧代表数据传输的最小的单位，每个帧都有序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("新的二进制格式")]),t._v("： HTTP/1.x的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景必然很多。基于这种考虑==HTTP/2.0的协议解析采用二进制格式==，方便且强大。")]),t._v(" "),_("li",[_("strong",[t._v("多路复用")]),t._v("： HTTP/2.0支持多路复用，这是HTTP/1.1持久连接的升级版。==多路复用可以发送多个请求==，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。")]),t._v(" "),_("li",[_("strong",[t._v("头部压缩")]),t._v("： HTTP/1.x的请求和响应头部带有大量信息，而且每次请求都要重复发送，==HTTP/2.0使用encoder来减少需要传输的头部大小==，通讯双方各自cache一份头部 fields表，既避免了重复头部的传输，又减小了需要传输的大小。")]),t._v(" "),_("li",[_("strong",[t._v("服务端推送")]),t._v("：\nHTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是被动的响应请求。也可以==新建“流”主动向客户端发送消息==。比如在浏览器刚请求HTML的时候就提前把可能会用到的js、css文件发送给客户端，减少等待的延迟，这就成为“服务端推送”（server push）。")])]),t._v(" "),_("p",[t._v("其他补充：")]),t._v(" "),_("ul",[_("li",[t._v("==HTTP1.1==虽然减少连接带来的性能消耗，但是==请求最大并发受到限制==，同一域下的HTTP连接数根据浏览器不同有所变化，==一般是6 ~ 8个==。而且一个TCP连接同一时刻只能处理一个请求，当前请求未结束之前，其他请求只能处于阻塞状态。")]),t._v(" "),_("li",[t._v("HTTP2.0中增加“多路复用”的机制，不再受限于浏览器的连接数限制。基于二进制分帧，客户端发送的数据会被分割成带有编号的碎片（二进制帧），然后将这些碎片同时发送给服务端，服务端接收到数据后根据编号再合并成完整的数据。服务端返回数据也同样遵循这个过程。")])]),t._v(" "),_("h3",{attrs:{id:"http-3-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-3-0"}},[t._v("#")]),t._v(" HTTP/3.0")]),t._v(" "),_("p",[t._v("HTTP/2.0 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中==出现了丢包的情况，那就会导致整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了==。出现包阻塞的原因是因为底层TCP协议导致的问题，Google 基于 UDP 协议推出了一个的 QUIC 协议，并且使用在了 HTTP/3 上。")]),t._v(" "),_("p",[t._v("QUIC 基于 UDP，但是UDP本身存在不稳定性等诸多问题，所以QUIC在UDP的基础上新增了很多功能，比如"),_("strong",[t._v("多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能")]),t._v("。")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("避免包阻塞")]),t._v("： 多个流的数据包在TCP连接上传输时，若一个流中的数据包传输出现问题，TCP需要等待该包重传后，才能继续传输其它流的数据包（TCP的队头阻塞没有彻底解决）。但在==基于UDP的QUIC协议中==，不同的流之间的数据传输真正实现了相互独立互不干扰，==某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响==。")]),t._v(" "),_("li",[_("strong",[t._v("快速重启会话")]),t._v("： 普通基于tcp的连接，是基于两端的ip和端口和协议来建立的。在网络切换场景，例如手机端切换了无线网，使用4G网络，会改变本身的ip，这就导致tcp连接必须重新创建。而==QUIC协议使用特有的UUID来标记每一次连接，在网络环境发生变化的时候，只要UUID不变，就能不需要握手，继续传输数据==。")])]),t._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),_("p",[t._v("HTTP/1.1有两个主要的缺点：安全性不足和性能不高。\nHTTP/2 完全兼容HTTP/1 ，是“更安全的HTTP、更快的HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验。\nQUIC基于UDP实现，是HTTP/3中的底层协议，该协议基于UDP，又提取了TCP中的精华，实现了即快又可靠的协议。")]),t._v(" "),_("h2",{attrs:{id:"http报文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http报文"}},[t._v("#")]),t._v(" http报文")]),t._v(" "),_("p",[t._v("用于HTTP协议交互的信息被称为HTTP报文。客户端的HTTP报文叫请求报文，服务端的HTTP报文叫响应报文。")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("请求报文")]),t._v(" 是由请求行（请求方法、协议版本）、请求首部（请求URI、客户端信息等）和内容实体（用户信息和资源信息等，可为空）构成。")]),t._v(" "),_("li",[_("code",[t._v("响应报文")]),t._v("是由状态行（协议版本、状态码）、响应首部（服务器名称、资源标识等）和内容实体（服务端返回的资源信息）构成。")])]),t._v(" "),_("h2",{attrs:{id:"请求方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#请求方法"}},[t._v("#")]),t._v(" 请求方法")]),t._v(" "),_("ul",[_("li",[t._v("GET：get方法一般用于获取服务器资源")]),t._v(" "),_("li",[t._v("POST：post方法一般用于传输实体主体")]),t._v(" "),_("li",[t._v("PUT：put方法一般用于传输文件")]),t._v(" "),_("li",[t._v("DELETE：delete方法用于删除文件")]),t._v(" "),_("li",[t._v("HEAD：head方法用于获取报文首部，不返回报文主体")]),t._v(" "),_("li",[t._v("OPTIONS：options方法用于询问请求URI资源支持的方法\n补充\n1、以上请求的使用场景\n2、请求数据只能用get请求吗\n3、get和post的区别\n4、restful API")])]),t._v(" "),_("h2",{attrs:{id:"状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态码"}},[t._v("#")]),t._v(" 状态码")]),t._v(" "),_("ul",[_("li",[t._v("2xx 成功，请求被正常处理")]),t._v(" "),_("li",[t._v("3xx  重定向，表示浏览器要执行特殊处理")]),t._v(" "),_("li",[t._v("4xx  客户端错误")]),t._v(" "),_("li",[t._v("5xx  服务器错误")])]),t._v(" "),_("p",[t._v("几个常考的错误码数")]),t._v(" "),_("ul",[_("li",[t._v("200  ok ，表示从客户端发来的请求在服务端被正确处理")]),t._v(" "),_("li",[t._v("206  进行范围请求成功。客户端发送了一个带range头的请求，服务端完成了他。响应体中只有range头中指定的这部分。")]),t._v(" "),_("li",[t._v("301  所请求的页面已经转移到新的URL（永久）")]),t._v(" "),_("li",[t._v("302  所请求的页面已经临时转移到新的URL（临时）")]),t._v(" "),_("li",[t._v("304  如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容并没有改变，则服务器应当返回这个状态码。304响应也是一种缓存机制。Web服务器对静态资源文件通常会采取缓存，因此在Web开发中你可以看到大量的304响应。 服务器给出的相应中通常会包含Etag来标识资源ID")]),t._v(" "),_("li",[t._v("401 （未授权）请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。")]),t._v(" "),_("li",[t._v("403  服务器拒绝请求。")])]),t._v(" "),_("h2",{attrs:{id:"connection为keep-alive表示什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#connection为keep-alive表示什么"}},[t._v("#")]),t._v(" connection为keep-alive表示什么")]),t._v(" "),_("p",[t._v("HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；keep-alive（持久连接）是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。")]),t._v(" "),_("p",[t._v("在 HTTP/1.0 协议中，如果请求头中包含：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("Connection: keep-alive\n\n")])])]),_("p",[t._v("则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。")]),t._v(" "),_("p",[t._v("在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("Connection: close\n\n")])])]),_("h2",{attrs:{id:"get和post区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get和post区别"}},[t._v("#")]),t._v(" get和post区别")]),t._v(" "),_("ul",[_("li",[t._v("GET在浏览器回退时是无害的，而POST会再次提交请求。")]),t._v(" "),_("li",[t._v("GET产生的URL地址可以被Bookmark，而POST不可以。")]),t._v(" "),_("li",[t._v("GET请求会被浏览器==主动cache==，而POST不会，除非手动设置。")]),t._v(" "),_("li",[t._v("GET请求只能进行url编码，而POST支持多种编码方式。")]),t._v(" "),_("li",[t._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。")]),t._v(" "),_("li",[t._v("GET请求在URL中传送的参数是有==长度限制==的，而POST么有。")]),t._v(" "),_("li",[t._v("对参数的数据类型，GET只接受ASCII字符，而POST没有限制。")]),t._v(" "),_("li",[t._v("GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。（body中的信息也可以获取到）")]),t._v(" "),_("li",[t._v("GET参数通过URL传递，POST放在Request body中。（一般规定这样，但是get也可以带body）")])]),t._v(" "),_("p",[t._v("以上答案都不是面试官想听到的，了解即可。")]),t._v(" "),_("p",[_("strong",[t._v("GET产生一个TCP数据包；POST产生两个TCP数据包")]),t._v("。")]),t._v(" "),_("ul",[_("li",[t._v("对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；")]),t._v(" "),_("li",[t._v("而对于POST，==浏览器先发送header==，服务器响应100 continue，浏览器==再发送data==，服务器响应200 ok（返回数据）。因为POST需要两步，时间上消耗的要多一点。")]),t._v(" "),_("li",[t._v("在网络环境好的情况下，发一次包的时间和发==两次包的时间差别基本可以无视==。而在网络环境差的情况下，==两次包的TCP在验证数据包完整性上，有非常大的优点==。")])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("并不是所有浏览器都会在POST中发送两次包，==Firefox就只发送一次==。")])]),t._v(" "),_("h3",{attrs:{id:"相同之处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相同之处"}},[t._v("#")]),t._v(" 相同之处")]),t._v(" "),_("p",[t._v("HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。")]),t._v(" "),_("h3",{attrs:{id:"关于安全性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关于安全性"}},[t._v("#")]),t._v(" 关于安全性")]),t._v(" "),_("p",[t._v("我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，==无论是GET还是POST都不够安全，因为HTTP本身是明文协议==。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。==这完全不是一个“是否容易在浏览器地址栏上看到“的问题==。为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是https——即用SSL协议协商出的密钥加密明文的http数据。这个加密的协议和HTTP协议本身相互独立。如果是利用HTTP开发公网的站点/App，要保证安全，==https是最最基本的要求==。")]),t._v(" "),_("p",[t._v("的确GET请求的参数更倾向于放在url上，因此有更多机会被泄漏。比如==携带私密信息的url会展示在地址栏上，还可以分享给第三方，就非常不安全了==。此外，从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的access log通常会输出完整的url，比如nginx的默认access log就是如此。如果==url上携带敏感数据，就会被记录下来==。但请注意，==就算私密数据在body里，也是可以被记录下来的==，因此如果请求要经过不信任的公网，避免泄密的唯一手段就是https。")]),t._v(" "),_("p",[t._v("问题：\nGet.post区别，为什么删除不能用get\n答案：1、url可以容易被分享  2、容易被篡改 3、数据包1个和2个的问题，2个完整性更好  4、发送数据大小")]),t._v(" "),_("p",[t._v("get能否加body\nApache Http Client 和  OkHttpClient 都不支持  GET 请求发送 Body 数据，而 AsyncHttpClient 是可以的。主要是 GET 被设计来用 URI 来识别资源，如果让它的请求体中携带数据，那么通常的缓存服务便失效了，URI 不能作为缓存的 Key。")]),t._v(" "),_("p",[t._v("参考链接")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://juejin.im/post/6844903844216832007",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端基础篇之HTTP协议"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://harttle.land/2015/08/15/http-status-code.html#header-11",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何理解HTTP响应的状态码？"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://lotabout.me/2019/Things-about-keepalive/",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP keep-alive二三事"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://byvoid.com/zhs/blog/http-keep-alive-header/",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 协议头部与Keep-alive模式详解"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw%3D%3D&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4",target:"_blank",rel:"noopener noreferrer"}},[t._v("99%的人都理解错了HTTP中GET与POST的区别"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://www.zhihu.com/question/28586791",target:"_blank",rel:"noopener noreferrer"}},[t._v("GET 和 POST 到底有什么区别？"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://blog.csdn.net/qq_26878363/article/details/86506369?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-86506369.nonecase",target:"_blank",rel:"noopener noreferrer"}},[t._v("关于Http Get请求是否可携带Body"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://segmentfault.com/a/1190000020714686#articleHeader16",target:"_blank",rel:"noopener noreferrer"}},[t._v("解密HTTP/2与HTTP/3的新特性"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://juejin.im/post/6869376045636648973?utm_source=gold_browser_extension",target:"_blank",rel:"noopener noreferrer"}},[t._v("金九银十，初中级前端面试复习总结「浏览器、HTTP、前端安全」"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);