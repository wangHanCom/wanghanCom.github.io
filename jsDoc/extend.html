<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原型与继承 | 汪涵的博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link>
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.98136e72.css" as="style"><link rel="preload" href="/assets/js/app.df490d21.js" as="script"><link rel="preload" href="/assets/js/2.9235f093.js" as="script"><link rel="preload" href="/assets/js/10.92f448a7.js" as="script"><link rel="prefetch" href="/assets/js/11.d81451ab.js"><link rel="prefetch" href="/assets/js/12.fe657e2d.js"><link rel="prefetch" href="/assets/js/13.673f55af.js"><link rel="prefetch" href="/assets/js/14.33419792.js"><link rel="prefetch" href="/assets/js/15.ab408685.js"><link rel="prefetch" href="/assets/js/16.41231623.js"><link rel="prefetch" href="/assets/js/17.f98cb10c.js"><link rel="prefetch" href="/assets/js/18.dc28497a.js"><link rel="prefetch" href="/assets/js/19.3bd23e42.js"><link rel="prefetch" href="/assets/js/20.48e0bcc4.js"><link rel="prefetch" href="/assets/js/21.4ca137be.js"><link rel="prefetch" href="/assets/js/22.fe35d04c.js"><link rel="prefetch" href="/assets/js/23.e2151993.js"><link rel="prefetch" href="/assets/js/24.42cdd1be.js"><link rel="prefetch" href="/assets/js/25.2ef590fe.js"><link rel="prefetch" href="/assets/js/26.88fd7535.js"><link rel="prefetch" href="/assets/js/27.aefa961a.js"><link rel="prefetch" href="/assets/js/28.5b4073a9.js"><link rel="prefetch" href="/assets/js/29.4c27b4b2.js"><link rel="prefetch" href="/assets/js/3.74014b60.js"><link rel="prefetch" href="/assets/js/30.f97becd7.js"><link rel="prefetch" href="/assets/js/31.92fc7f70.js"><link rel="prefetch" href="/assets/js/32.d7c4f275.js"><link rel="prefetch" href="/assets/js/33.8d2027ca.js"><link rel="prefetch" href="/assets/js/34.adb9aee5.js"><link rel="prefetch" href="/assets/js/35.34cb4c23.js"><link rel="prefetch" href="/assets/js/4.ddf5fb83.js"><link rel="prefetch" href="/assets/js/5.2f6ceb2d.js"><link rel="prefetch" href="/assets/js/6.acebe267.js"><link rel="prefetch" href="/assets/js/7.4f5a488b.js"><link rel="prefetch" href="/assets/js/8.d3b85309.js"><link rel="prefetch" href="/assets/js/9.395837cf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98136e72.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">汪涵的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jsDoc/" aria-current="page" class="sidebar-link">jsBridge原理 ✅</a></li><li><a href="/jsDoc/es6.html" class="sidebar-link">es6</a></li><li><a href="/jsDoc/promise.html" class="sidebar-link">promise</a></li><li><a href="/jsDoc/copy.html" class="sidebar-link">防抖节流/深浅拷贝</a></li><li><a href="/jsDoc/evenloop.html" class="sidebar-link">evenloop/事件机制</a></li><li><a href="/jsDoc/extend.html" aria-current="page" class="active sidebar-link">原型与继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jsDoc/extend.html#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/jsDoc/extend.html#继承的几种方式" class="sidebar-link">继承的几种方式</a></li><li class="sidebar-sub-header"><a href="/jsDoc/extend.html#继承时的this值" class="sidebar-link">继承时的this值</a></li><li class="sidebar-sub-header"><a href="/jsDoc/extend.html#for…in-循环" class="sidebar-link">for…in 循环</a></li><li class="sidebar-sub-header"><a href="/jsDoc/extend.html#proto-总结" class="sidebar-link">_proto_总结</a></li><li class="sidebar-sub-header"><a href="/jsDoc/extend.html#f-prototype" class="sidebar-link">F.prototype</a></li><li class="sidebar-sub-header"><a href="/jsDoc/extend.html#f-prototype总结" class="sidebar-link">F.prototype总结</a></li><li class="sidebar-sub-header"><a href="/jsDoc/extend.html#es6的继承用es5怎么写" class="sidebar-link">es6的继承用es5怎么写</a></li></ul></li><li><a href="/jsDoc/scope.html" class="sidebar-link">执行上下文/作用域链/闭包</a></li><li><a href="/jsDoc/this.html" class="sidebar-link">this/call/apply/bind</a></li><li><a href="/jsDoc/v8Collection.html" class="sidebar-link">v8垃圾回收机制</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="原型与继承"><a href="#原型与继承" class="header-anchor">#</a> 原型与继承</h1> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <p>首先我们需要明确两点：
1️⃣__proto__和constructor是对象独有的。
2️⃣prototype属性是函数独有的；</p> <p>限制：</p> <ul><li>引用不能形成闭环。如果我们试图在一个闭环中分配 <strong>proto</strong>，JavaScript 会抛出错误。</li> <li><strong>proto</strong> 的值可以是对象，也可以是 null。而其他的类型都会被忽略。</li></ul> <h3 id="proto"><a href="#proto" class="header-anchor">#</a> <strong>proto</strong></h3> <p>ECMAScript 规范描述 <code>prototype</code> 是一个<strong>隐式引用</strong>，但之前的一些浏览器，已经私自实现了<code>__proto__</code>这个属性，使得可以通过 <code>obj.__proto__</code> 这个显式的属性访问，访问到被定义为隐式属性的 <code>prototype</code>。</p> <p><code>__proto__</code>属性既不能被 <code>for in</code> 遍历出来，也不能被 <code>Object.keys(obj)</code> 查找出来。</p> <p><code>__proto__</code>是对象所独有的，并且<code>__proto__</code>是一个对象指向他的原型对象。我们也可以理解为父类对象。当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就会去其父类的<code>__proto__</code>属性所指向的父类的父类上去查找。直到找到 null。而这个查找的过程，也就构成了==原型链==。</p> <h3 id="prototype"><a href="#prototype" class="header-anchor">#</a> prototype</h3> <p>prototype是函数所独有的。</p> <h3 id="constructor"><a href="#constructor" class="header-anchor">#</a> constructor</h3> <p>任何函数，只要通过new操作符来调用，那它就可以作为构造函数。
在默认情况下，所有原型对象都会自动获取一个<code>constructor</code>属性，这个属性是一个指向<code>prototype</code>属性所在函数的指针。</p> <h3 id="instanceof"><a href="#instanceof" class="header-anchor">#</a> instanceof</h3> <p>实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">instance_of</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">L</span><span class="token punctuation">,</span> <span class="token constant">R</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//L 表示左表达式，R 表示右表达式</span>
 <span class="token keyword">var</span> <span class="token constant">O</span> <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment">// 取 R 的显示原型</span>
 <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span><span class="token comment">// 取 L 的隐式原型</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">L</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">O</span> <span class="token operator">===</span> <span class="token constant">L</span><span class="token punctuation">)</span><span class="token comment">// 这里重点：当 O 严格等于 L 时，返回 true </span>
     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
   <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre></div><h3 id="new的实现"><a href="#new的实现" class="header-anchor">#</a> new的实现</h3> <p>new操作符做了以下几件事</p> <ul><li>它创建了一个全新的对象</li> <li>它会执行<code>[[Prototype]]</code>（也就是__proto__）链接</li> <li>它使this指向新建的对象</li> <li>通过<code>new</code> 创建的每个对象最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li> <li>如果函数没有返回对象型Object（包括Function，Array，Date，RegExg，Error），那么<code>new</code> 表达式中的函数调用将返回该对象的引用。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">New</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> res<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span>prototype<span class="token operator">!==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        res<span class="token punctuation">.</span>__proto__<span class="token operator">=</span>func<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment">//通过原型继承</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> ret<span class="token operator">=</span><span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使this指向新创建的对象，执行构造函数</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> ret<span class="token operator">===</span><span class="token string">&quot;object&quot;</span><span class="token operator">||</span><span class="token keyword">typeof</span> ret<span class="token operator">===</span><span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>ret<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//测试</span>
<span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//等价于</span>
<span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="继承的几种方式"><a href="#继承的几种方式" class="header-anchor">#</a> 继承的几种方式</h2> <h3 id="原型链继承"><a href="#原型链继承" class="header-anchor">#</a> 原型链继承</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jchermy'</span><span class="token punctuation">;</span><span class="token comment">// this.names = [&quot;aa&quot;, &quot;bb&quot;];时修改一个实例，其他也会变化</span>
<span class="token punctuation">}</span>

<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span>  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">/*==================继承实现===================*/</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*====================测试=====================*/</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//jchermy</span>

</code></pre></div><p>由此我们可以得出原型链继承的缺点：</p> <ol><li>引用类型的属性被所有实例共享</li> <li>在创建Child实例时，不能向Parent传参</li> <li>基于构造函数和原型链</li> <li>通过 hasOwnProperty() 方法来确定自身属性与其原型属性</li> <li>通过 isPrototypeOf() 方法来确定原型和实例的关系</li> <li>在实例中可以修改原型中引用类型的值</li></ol> <h3 id="构造函数继承"><a href="#构造函数继承" class="header-anchor">#</a> 构造函数继承</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;parent &quot;</span><span class="token operator">+</span>name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sayName<span class="token operator">=</span><span class="token function">fucntion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;child&quot;</span><span class="token operator">+</span>name<span class="token punctuation">;</span>
    <span class="token comment">/*===================继承实现==================*/</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//借调父的构造函数</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'hemin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chil1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;parent hemin&quot;</span>

<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;parent aa&quot;</span>
</code></pre></div><p>缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法</p> <h3 id="组合式继承"><a href="#组合式继承" class="header-anchor">#</a> 组合式继承</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*======================继承实现=======================*/</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//借调父的构造函数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 <span class="token comment">/*======================继承实现=======================*/</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//和父关联，继承关系</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>

<span class="token comment">/*=========测试==========*/</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
child1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//修改其中一个实例</span>

child1<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">//&quot;aa&quot;</span>
child1<span class="token punctuation">.</span>age<span class="token punctuation">;</span> <span class="token comment">//18</span>
child1<span class="token punctuation">.</span>colors<span class="token punctuation">;</span> <span class="token comment">//[&quot;red&quot;, &quot;blue&quot;,&quot;black&quot;]</span>

<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;bb&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
child2<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">//&quot;bb&quot;</span>
child2<span class="token punctuation">.</span>age<span class="token punctuation">;</span> <span class="token comment">//20</span>
child2<span class="token punctuation">.</span>colors<span class="token punctuation">;</span> <span class="token comment">//[&quot;red&quot;, &quot;blue&quot;]</span>
</code></pre></div><p>然而组合继承也有一个缺点，就是会调用两次父构造函数。
优点</p> <ol><li>可以复用原型上定义的方法</li> <li>可以保证每个函数有自己的属性，可以解决原型中引用类型值被修改的问题
缺点</li> <li>staff 会被调用 2 次：
第 1 次是employee.prototype = new staff();，第 2 次是调用 staff.call(this)。</li></ol> <h3 id="原型式继承-object-create"><a href="#原型式继承-object-create" class="header-anchor">#</a> 原型式继承/ Object.create()</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//同Object.create的实现</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'jchermy'</span><span class="token punctuation">,</span>
    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bb&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token comment">/*==============测试==============*/</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 注意：修改person1.name的值，person2.name的值并未发生改变，</span>
<span class="token comment">// 并不是因为person1和person2有独立的 name 值，而是因为person1.name = 'person1'，给person1添加了 name 值，并非修改了原型上的 name 值。</span>

person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;xiaomi&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;jchermy&quot;</span>

person2<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;cc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]</span>
</code></pre></div><p>缺点：包含引用类型的属性值始终会共享相应的值，与原型链继承一样</p> <h3 id="寄生式继承"><a href="#寄生式继承" class="header-anchor">#</a> 寄生式继承</h3> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    clone<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> clone<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;jchermy&quot;</span><span class="token punctuation">,</span>
    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bb&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;xiaomi&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;xiaomi&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;jchermy&quot;</span>

person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;xxx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;aa&quot;, &quot;bb&quot;, &quot;xxx&quot;]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;aa&quot;, &quot;bb&quot;, &quot;xxx&quot;]</span>
</code></pre></div><p>缺点:</p> <ol><li>跟借用构造函数模式一样，每次创建对象都会创建一遍方法</li> <li>包含引用类型的属性值始终会共享相应的值</li></ol> <h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="header-anchor">#</a> 寄生组合式继承</h3> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token comment">//关键的三步</span>
  <span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//以上三步可以用 Child.prototype = Object.create(Parent)</span>
  <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>

  <span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'xiaomi'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child2</span><span class="token punctuation">(</span><span class="token string">'aa'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//xiaomi</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//aa</span>

  child1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  child1<span class="token punctuation">.</span>colors<span class="token punctuation">;</span> <span class="token comment">//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span>
  child2<span class="token punctuation">.</span>colors<span class="token punctuation">;</span> <span class="token comment">//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span>
</code></pre></div><p>这种方式的高效率体现它只调用了一次 <code>Parent</code>构造函数，并且因此避免了在 <code>Parent.prototype</code> 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 <code>instanceof</code>和 <code>isPrototypeOf</code>。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p> <p>参考链接
<a href="https://github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener noreferrer">JavaScript深入之继承的多种方式和优缺点<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="继承时的this值"><a href="#继承时的this值" class="header-anchor">#</a> 继承时的this值</h2> <p>this 根本不受原型的影响。</p> <p>无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，this 始终是点符号 . 前面的对象。</p> <p>因此，setter 调用 admin.fullName= 使用 admin 作为 this，而不是 user。</p> <h2 id="for…in-循环"><a href="#for…in-循环" class="header-anchor">#</a> for…in 循环</h2> <p>for..in 循环也会迭代继承的属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  eats<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token punctuation">{</span>
  jumps<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  __proto__<span class="token operator">:</span> animal
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Object.keys 只返回自己的 key</span>
<span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>rabbit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jumps</span>

<span class="token comment">// for..in 会遍历自己以及继承的键</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">in</span> rabbit<span class="token punctuation">)</span> <span class="token function">alert</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jumps，然后是 eats</span>
</code></pre></div><p>如果这不是我们想要的，并且我们想排除继承的属性，那么这儿有一个内建方法 obj.hasOwnProperty(key)：如果 obj 具有自己的（非继承的）名为 key 的属性，则返回 true。</p> <h3 id="for-in会忽略不可枚举属性"><a href="#for-in会忽略不可枚举属性" class="header-anchor">#</a> for..in会忽略不可枚举属性</h3> <p>如果 for..in 循环会列出继承的属性，那为什么 hasOwnProperty 没有像 eats 和 jumps 那样出现在 for..in 循环中？</p> <p>答案很简单：它是不可枚举的。就像 Object.prototype 的其他属性，hasOwnProperty 有 enumerable:false 标志。**并且 for..in 只会列出可枚举的属性。**这就是为什么它和其余的 Object.prototype 属性都未被列出。</p> <p>几乎所有其他键/值获取方法，<strong>例如 <code>Object.keys</code>和<code>Object.values</code> 等，都会忽略继承的属性。</strong></p> <p>它们只会对对象自身进行操作。<strong>不考虑 继承自原型的属性</strong>。</p> <p>for..of用法见<code>es6/for...of循环</code></p> <h2 id="proto-总结"><a href="#proto-总结" class="header-anchor">#</a> __proto__总结</h2> <ul><li>在 JavaScript 中，所有的对象都有一个隐藏的 [[Prototype]] 属性，它要么是另一个对象，要么就是 null。</li> <li>我们可以使用 obj.<strong>proto</strong> 访问它（历史遗留下来的 getter/setter，这儿还有其他方法，很快我们就会讲到）。</li> <li>通过 [[Prototype]] 引用的对象被称为“原型”。
如果我们想要读取 obj 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。</li> <li>写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。</li> <li>如果我们调用 obj.method()，而且 method 是从原型中获取的，this 仍然会引用 obj。因此，方法始终与当前对象一起使用，即使方法是继承的。</li> <li>for..in 循环在其自身和继承的属性上进行迭代。所有其他的键/值获取方法仅对对象本身起作用。</li></ul> <p>参考链接
<a href="https://zh.javascript.info/prototype-inheritance" target="_blank" rel="noopener noreferrer">原型继承<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="f-prototype"><a href="#f-prototype" class="header-anchor">#</a> F.prototype</h2> <p>可以使用诸如<code>new F()</code> 这样的构造函数来创建一个新对象。</p> <p>如果 <code>F.prototype</code>是一个对象，那么 new 操作符会使用它为新对象设置 <code>[[Prototype]]</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  eats<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> animal<span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token string">&quot;White Rabbit&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等价 rabbit.__proto__ == animal</span>

<span class="token function">alert</span><span class="token punctuation">(</span> rabbit<span class="token punctuation">.</span>eats <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p><code>F.prototype</code>属性仅在 <code>new F</code> 被调用时使用，它为新对象的 <code>[[Prototype]]</code>赋值。如果在创建之后，F.prototype 属性有了变化<code>（F.prototype = &lt;another object&gt;）</code>，那么通过 new F 创建的新对象也将随之拥有新的对象作为 <code>[[Prototype]]</code>，== 但已经存在的对象将保持旧有的值。==</p> <h3 id="默认的-f-prototype，构造器属性"><a href="#默认的-f-prototype，构造器属性" class="header-anchor">#</a> 默认的 F.prototype，构造器属性</h3> <p>每个函数都有<code>&quot;prototype&quot;</code> 属性，即使我们没有提供它。</p> <p>默认的<code>&quot;prototype&quot;</code>是一个只有属性 <code>constructor</code>的对象，属性 <code>constructor</code>指向函数自身。</p> <h2 id="f-prototype总结"><a href="#f-prototype总结" class="header-anchor">#</a> F.prototype总结</h2> <ul><li><code>F.prototype</code>属性（不要把它与 [[Prototype]] 弄混了）在 <code>new F</code> 被调用时为新对象的 [[Prototype]] 赋值。</li> <li><code>F.prototype</code> 的值要么是一个对象，要么就是 null：其他值都不起作用。</li> <li><code>&quot;prototype&quot;</code> 属性仅在设置了一个构造函数（constructor function），<strong>并通过 new 调用时，才具有这种特殊的影响</strong>。</li></ul> <p>参考链接
<a href="https://zh.javascript.info/function-prototype" target="_blank" rel="noopener noreferrer">F.prototype<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="es6的继承用es5怎么写"><a href="#es6的继承用es5怎么写" class="header-anchor">#</a> es6的继承用es5怎么写</h2> <p>es6类</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>es5的写法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 用纯函数重写 class User</span>

<span class="token comment">// 1. 创建构造器函数</span>
<span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 函数的原型（prototype）默认具有 &quot;constructor&quot; 属性，</span>
<span class="token comment">// 所以，我们不需要创建它</span>

<span class="token comment">// 2. 将方法添加到原型</span>
<span class="token class-name">User</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>扩展</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">a</span><span class="token punctuation">{</span>
  <span class="token comment">// constructor(){</span>
  <span class="token comment">//   this.sayHi=this.sayHi.bind(this)</span>
  <span class="token comment">// }</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//绑在原型上，所以相等</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">b</span><span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">sayHi</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token comment">//绑在实例上，所以不相等</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">var</span> a1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> b1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a1<span class="token punctuation">.</span>sayHi<span class="token operator">===</span>a2<span class="token punctuation">.</span>sayHi<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>sayHi<span class="token operator">===</span>b2<span class="token punctuation">.</span>sayHi<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a1<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a2<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b2<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>参考链接
<a href="https://zh.javascript.info/class" target="_blank" rel="noopener noreferrer">Class 基本语法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/jsDoc/evenloop.html" class="prev">
        evenloop/事件机制
      </a></span> <span class="next"><a href="/jsDoc/scope.html">
        执行上下文/作用域链/闭包
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.df490d21.js" defer></script><script src="/assets/js/2.9235f093.js" defer></script><script src="/assets/js/10.92f448a7.js" defer></script>
  </body>
</html>
