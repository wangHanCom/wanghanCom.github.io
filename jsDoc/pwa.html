<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Service Worker | 汪涵的博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link>
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.98136e72.css" as="style"><link rel="preload" href="/assets/js/app.df490d21.js" as="script"><link rel="preload" href="/assets/js/2.9235f093.js" as="script"><link rel="preload" href="/assets/js/12.fe657e2d.js" as="script"><link rel="prefetch" href="/assets/js/10.92f448a7.js"><link rel="prefetch" href="/assets/js/11.d81451ab.js"><link rel="prefetch" href="/assets/js/13.673f55af.js"><link rel="prefetch" href="/assets/js/14.33419792.js"><link rel="prefetch" href="/assets/js/15.ab408685.js"><link rel="prefetch" href="/assets/js/16.41231623.js"><link rel="prefetch" href="/assets/js/17.f98cb10c.js"><link rel="prefetch" href="/assets/js/18.dc28497a.js"><link rel="prefetch" href="/assets/js/19.3bd23e42.js"><link rel="prefetch" href="/assets/js/20.48e0bcc4.js"><link rel="prefetch" href="/assets/js/21.4ca137be.js"><link rel="prefetch" href="/assets/js/22.fe35d04c.js"><link rel="prefetch" href="/assets/js/23.e2151993.js"><link rel="prefetch" href="/assets/js/24.42cdd1be.js"><link rel="prefetch" href="/assets/js/25.2ef590fe.js"><link rel="prefetch" href="/assets/js/26.88fd7535.js"><link rel="prefetch" href="/assets/js/27.aefa961a.js"><link rel="prefetch" href="/assets/js/28.5b4073a9.js"><link rel="prefetch" href="/assets/js/29.4c27b4b2.js"><link rel="prefetch" href="/assets/js/3.74014b60.js"><link rel="prefetch" href="/assets/js/30.f97becd7.js"><link rel="prefetch" href="/assets/js/31.92fc7f70.js"><link rel="prefetch" href="/assets/js/32.d7c4f275.js"><link rel="prefetch" href="/assets/js/33.8d2027ca.js"><link rel="prefetch" href="/assets/js/34.adb9aee5.js"><link rel="prefetch" href="/assets/js/35.34cb4c23.js"><link rel="prefetch" href="/assets/js/4.ddf5fb83.js"><link rel="prefetch" href="/assets/js/5.2f6ceb2d.js"><link rel="prefetch" href="/assets/js/6.acebe267.js"><link rel="prefetch" href="/assets/js/7.4f5a488b.js"><link rel="prefetch" href="/assets/js/8.d3b85309.js"><link rel="prefetch" href="/assets/js/9.395837cf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98136e72.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">汪涵的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jsDoc/" aria-current="page" class="sidebar-link">jsBridge原理 ✅</a></li><li><a href="/jsDoc/es6.html" class="sidebar-link">es6</a></li><li><a href="/jsDoc/promise.html" class="sidebar-link">promise</a></li><li><a href="/jsDoc/copy.html" class="sidebar-link">防抖节流/深浅拷贝</a></li><li><a href="/jsDoc/evenloop.html" class="sidebar-link">evenloop/事件机制</a></li><li><a href="/jsDoc/extend.html" class="sidebar-link">原型与继承</a></li><li><a href="/jsDoc/scope.html" class="sidebar-link">执行上下文/作用域链/闭包</a></li><li><a href="/jsDoc/this.html" class="sidebar-link">this/call/apply/bind</a></li><li><a href="/jsDoc/v8Collection.html" class="sidebar-link">v8垃圾回收机制</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> Service Worker</h1> <p>Service Worker是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。 现在，它们已包括如推送通知和后台同步等功能。 将来，Service Worker将会支持如定期同步或地理围栏等其他功能。</p> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p>第一次访问时Service Worker的生命周期
installing → installed → activating → activated</p> <p>在js没有修改的情况下刷新，直接显示当前激活态
installed（注册成功） → activated</p> <p>修改了Service Worker注册JS，然后重载的时候旧的Service Worker还在跑，新的Service Worker已经安装等待激活
注册成功 → waiting → installed</p> <h2 id="安装"><a href="#安装" class="header-anchor">#</a> 安装</h2> <p>通过注册 Service Worker，你可以告诉浏览器你的 Service Worker 的 JavaScript 文件的位置。</p> <div class="language- extra-class"><pre class="language-text"><code>if(serviceWorker in navigator){
    window.addEventListener('load',function(){
        navigator.serviceWorker.register('/sw.js').then(function(registration){
            console.log('ServiceWorker registration successful');
        },function(err){
            console.log('ServiceWorker registration failed',err);
        })
    })
}
</code></pre></div><ul><li>每次页面加载时都可以调用 <code>navigator.serviceWorker.register()</code> 方法，浏览器会判断 Service Worker 是否已经注册，根据注册情况会对应的给出正确处理。<code>register()</code>方法的一个重要细节是 Service Worker 文件的位置。在本例中，可以看到 Service Worker 文件位于域的根目录，这个 Service Worker 将为这个域中的所有内容接收 fetch 事件。</li> <li>用户第一次访问你的 Web 应用程序。目前还没有 Service Worker，浏览器无法预先知道最终是否会安装 Service Worker。如果安装了 Service Worker，浏览器将需要为这个额外的线程花费额外的 CPU 和内存，否则浏览器将把这些额外的 CPU 和内存用于呈现 Web 页面。</li> <li>如果在页面上安装一个 Service Worker，就可能会有延迟加载和渲染的风险 —— 而不是尽快让你的用户可以使用该页面。</li> <li>注意，这种情况对第一次的访问页面时才会有。后续的页面访问不会受到 Service Worker 安装的影响。一旦 Service Worker 在第一次访问页面时被激活，它就可以处理加载/缓存事件，以便后续访问 Web 应用程序。</li></ul> <h2 id="激活"><a href="#激活" class="header-anchor">#</a> 激活</h2> <p>在激活步骤之后，Service Worker 将控制所有属于其范围的页面，尽管第一次注册 Service Worker 的页面将不会被控制，直到再次加载。
Service Worker 一旦掌控，它将处于以下两种状态之一：</p> <ul><li>处理从网页发出网络请求或消息时发生的提取和消息事件</li> <li>Service Worker 将被终止以节省内存</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 缓存更新
self.addEventListener('activate', function(event) {
  event.waitUntil(
  //检索缓存中所有键
    caches.keys().then(function(cacheNames) {
      return Promise.all(
      //遍历所有缓存文件
        cacheNames.map(function(cacheName) {
          // 如果当前版本和缓存版本不一致则删除
          if (cacheName !== VERSION) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>self.addEventListener('activate', function(event) { /* 激活后... */ });
</code></pre></div><blockquote><p>'activate'用来缓存更新</p></blockquote> <h2 id="安装-2"><a href="#安装-2" class="header-anchor">#</a> 安装</h2> <p>以下是处理安装事件时需要采取的步骤:</p> <ul><li>开启一个缓存</li> <li>缓存我们的文件</li> <li>确认是否缓存了所有必需的资源</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const pluckDeep = ke;
var CACHE_NAME = 'my-web-app-cache';
var urlToCache = [
   '/',
   '/styles/main.css',
   '/scripts/app.js',
   '/scripts/lib.js'
];
self.addEventListener('install',function(event){
    // event.waitUntil 需要一个promise ，以了解安装需要多长时间
    event.waitUntil(
        caches.open(CACHE_NAME).then(function(cache){
            console.log('Opened cache');
            return cache.addAll(urlToCache);
        })
    );
});
</code></pre></div><p>调用了caches.open() 和我们想要的缓存名称, 之后调用 cache.addAll() 并传入文件数组。 这是一个promise 链（ caches.open() 和 cache.addAll() ）。 event.waitUntil() 方法接受一个承诺，并使用它来知道安装需要多长时间，以及它是否成功。</p> <div class="language- extra-class"><pre class="language-text"><code>self.addEventListener('install', function(event) { /* 安装后... */ });
</code></pre></div><blockquote><p>'install'用来缓存文件</p></blockquote> <h2 id="fetch事件"><a href="#fetch事件" class="header-anchor">#</a> fetch事件</h2> <div class="language- extra-class"><pre class="language-text"><code>// 捕获请求并返回缓存数据
self.addEventListener('fetch', function(event) {
  event.respondWith(
   //此方法查看请求，并从Service worker创建的所有缓存中找到已缓存的结果
  caches.match(event.request).catch(function() {
    return fetch(event.request);
  }).then(function(response) {
    caches.open(VERSION).then(function(cache) {
    //将请求添加到缓存中以备将来查询
      cache.put(event.request, response);
    });
    return response.clone();
  }).catch(function() {
    return caches.match('./static/mm1.jpg');
  }));
});
</code></pre></div><p>Service Worker还支持fetch事件，来响应和拦截各种请求。</p> <div class="language- extra-class"><pre class="language-text"><code>self.addEventListener('fetch', function(event) { /* 请求后... */ });
</code></pre></div><blockquote><p>'fetch'用来拦截请求直接返回缓存数据</p></blockquote> <h2 id="要求-https-的原因"><a href="#要求-https-的原因" class="header-anchor">#</a> 要求 HTTPS 的原因</h2> <p>在构建 Web 应用程序时，通过 localhost 使用 Service Workers，但是一旦将其部署到生产环境中，就需要准备好 HTTPS( 这是使用HTTPS 的最后一个原因)。
使用 Service Worker，可以很容易被劫持连接并伪造响应。如果不使用 HTTPs，人的web应用程序就容易受到黑客的攻击。
为了更安全，你需要在通过 HTTPS 提供的页面上注册 Service Worker，以便知道浏览器接收的 Service Worker 在通过网络传输时未被修改。</p> <h2 id="pwa技术（待补充）"><a href="#pwa技术（待补充）" class="header-anchor">#</a> PWA技术（待补充）</h2> <p>PWA全称为“Progressive Web Apps”，渐进式网页应用。功效显著，收益明显
PWA的核心技术包括：</p> <ul><li>Web App Manifest – 在主屏幕添加app图标，定义手机标题栏颜色之类</li> <li>Service Worker – 缓存，离线开发，以及地理位置信息处理等</li> <li>App Shell – 先显示APP的主结构，再填充主数据，更快显示更好体验</li> <li>Push Notification – 消息推送，之前有写过“简单了解HTML5中的Web Notification桌面通知”
Service Worker仅仅是PWA技术中的一部分，但是又独立于PWA。</li></ul> <p>参考链接</p> <ul><li><a href="https://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/" target="_blank" rel="noopener noreferrer">借助Service Worker和cacheStorage缓存及离线开发<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/qq449245884/xiaozhi/issues/8" target="_blank" rel="noopener noreferrer">JavaScript 是如何工作的：Service Worker 的生命周期及使用场景<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/6844904052166230030#heading-2" target="_blank" rel="noopener noreferrer">PWA概念通识面试题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.df490d21.js" defer></script><script src="/assets/js/2.9235f093.js" defer></script><script src="/assets/js/12.fe657e2d.js" defer></script>
  </body>
</html>
