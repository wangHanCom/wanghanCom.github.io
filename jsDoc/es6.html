<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>es6 | 汪涵的博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link>
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.98136e72.css" as="style"><link rel="preload" href="/assets/js/app.df490d21.js" as="script"><link rel="preload" href="/assets/js/2.9235f093.js" as="script"><link rel="preload" href="/assets/js/8.d3b85309.js" as="script"><link rel="prefetch" href="/assets/js/10.92f448a7.js"><link rel="prefetch" href="/assets/js/11.d81451ab.js"><link rel="prefetch" href="/assets/js/12.fe657e2d.js"><link rel="prefetch" href="/assets/js/13.673f55af.js"><link rel="prefetch" href="/assets/js/14.33419792.js"><link rel="prefetch" href="/assets/js/15.ab408685.js"><link rel="prefetch" href="/assets/js/16.41231623.js"><link rel="prefetch" href="/assets/js/17.f98cb10c.js"><link rel="prefetch" href="/assets/js/18.dc28497a.js"><link rel="prefetch" href="/assets/js/19.3bd23e42.js"><link rel="prefetch" href="/assets/js/20.48e0bcc4.js"><link rel="prefetch" href="/assets/js/21.4ca137be.js"><link rel="prefetch" href="/assets/js/22.fe35d04c.js"><link rel="prefetch" href="/assets/js/23.e2151993.js"><link rel="prefetch" href="/assets/js/24.42cdd1be.js"><link rel="prefetch" href="/assets/js/25.2ef590fe.js"><link rel="prefetch" href="/assets/js/26.88fd7535.js"><link rel="prefetch" href="/assets/js/27.aefa961a.js"><link rel="prefetch" href="/assets/js/28.5b4073a9.js"><link rel="prefetch" href="/assets/js/29.4c27b4b2.js"><link rel="prefetch" href="/assets/js/3.74014b60.js"><link rel="prefetch" href="/assets/js/30.f97becd7.js"><link rel="prefetch" href="/assets/js/31.92fc7f70.js"><link rel="prefetch" href="/assets/js/32.d7c4f275.js"><link rel="prefetch" href="/assets/js/33.8d2027ca.js"><link rel="prefetch" href="/assets/js/34.adb9aee5.js"><link rel="prefetch" href="/assets/js/35.34cb4c23.js"><link rel="prefetch" href="/assets/js/4.ddf5fb83.js"><link rel="prefetch" href="/assets/js/5.2f6ceb2d.js"><link rel="prefetch" href="/assets/js/6.acebe267.js"><link rel="prefetch" href="/assets/js/7.4f5a488b.js"><link rel="prefetch" href="/assets/js/9.395837cf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98136e72.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">汪涵的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jsDoc/" aria-current="page" class="sidebar-link">jsBridge原理 ✅</a></li><li><a href="/jsDoc/es6.html" aria-current="page" class="active sidebar-link">es6</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#let-const（常用）" class="sidebar-link">let/const（常用）</a></li><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#箭头函数" class="sidebar-link">箭头函数</a></li><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#iterator迭代器" class="sidebar-link">iterator迭代器</a></li><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#for-of循环" class="sidebar-link">for...of循环</a></li><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#es6-module" class="sidebar-link">ES6 Module</a></li><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#proxy（重点）" class="sidebar-link">Proxy（重点）</a></li><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#proxy" class="sidebar-link">proxy</a></li><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#reflect" class="sidebar-link">Reflect</a></li><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#class" class="sidebar-link">class</a></li><li class="sidebar-sub-header"><a href="/jsDoc/es6.html#es6转换到es5" class="sidebar-link">es6转换到es5</a></li></ul></li><li><a href="/jsDoc/promise.html" class="sidebar-link">promise</a></li><li><a href="/jsDoc/copy.html" class="sidebar-link">防抖节流/深浅拷贝</a></li><li><a href="/jsDoc/evenloop.html" class="sidebar-link">evenloop/事件机制</a></li><li><a href="/jsDoc/extend.html" class="sidebar-link">原型与继承</a></li><li><a href="/jsDoc/scope.html" class="sidebar-link">执行上下文/作用域链/闭包</a></li><li><a href="/jsDoc/this.html" class="sidebar-link">this/call/apply/bind</a></li><li><a href="/jsDoc/v8Collection.html" class="sidebar-link">v8垃圾回收机制</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="es6"><a href="#es6" class="header-anchor">#</a> es6</h1> <h2 id="let-const（常用）"><a href="#let-const（常用）" class="header-anchor">#</a> let/const（常用）</h2> <h3 id="块级作用域"><a href="#块级作用域" class="header-anchor">#</a> 块级作用域</h3> <ul><li>与var不同的是，let/const会创建一个块级作用域（通俗讲就是一个花括号内是一个新的作用域）</li> <li>使用let/const关键字声明变量的for循环，除了会创建块级作用域，还会将它绑定到每个循环中，确保对上个循环结束时候的值进行重新赋值。<strong>每次循环都会声明一</strong>次（对比var声明的for循环只会声明一次）</li></ul> <h3 id="暂时性死区"><a href="#暂时性死区" class="header-anchor">#</a> 暂时性死区</h3> <p>由let/const声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问</p> <ul><li>var在创建时就被初始化，并且赋值为undefined</li> <li>let/const在进入块级作用域后，<strong>会因为提升的原因先创建，但不会被初始化</strong>，直到声明语句执行的时候才被初始化，初始化的时候如<strong>果使用let声明的变量没有赋值，则会默认赋值为undefined</strong>，而<strong>const必须在初始化的时候赋值</strong>。而创建到初始化之间的代码片段就形成了暂时性死区</li></ul> <h3 id="const"><a href="#const" class="header-anchor">#</a> const</h3> <ul><li>const声明变量的时候必须赋值，否则会报错，同样使用const声明的变量被修改了也会报错</li> <li>const声明变量不能改变，如果声明的是一个引用类型，则不能改变它的内存地址</li> <li>没有显式的声明块级作用域，let/const声明的变量却没有变为全局变量</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment">//undefined</span>
</code></pre></div><h2 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h2> <p>箭头函数对于使用function关键字创建的函数有以下区别</p> <ul><li>箭头函数没有arguments（建议使用更好的语法，剩余运算符替代）</li> <li>箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）</li> <li>箭头函数没有自己this，它的this是词法的，引用的是上下文的this，即在你写这行代码的时候就箭头函数的this就已经和外层执行上下文的this绑定了</li></ul> <h2 id="iterator迭代器"><a href="#iterator迭代器" class="header-anchor">#</a> iterator迭代器</h2> <p>对于可迭代的数据解构，ES6在内部部署了一个[Symbol.iterator]属性，它是一个函数，执行后会返回iterator对象（也叫迭代器对象），而生成iterator对象[Symbol.iterator]属性叫iterator接口,有这个接口的数据结构即被视为可迭代的。</p> <p>默认部署iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代）</p> <ul><li>Array</li> <li>Map</li> <li>Set</li> <li>String</li> <li>TypedArray（类数组）</li> <li>函数的 arguments 对象</li> <li>NodeList 对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> iterator<span class="token operator">=</span>arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//需要使用键名的方式访问</span>
iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//{value:1,done:false}</span>
iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//{value:2,done:false}</span>
iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//{value:3,done:false}</span>
iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//{value:undefined,done:true}</span>
</code></pre></div><p>总结：</p> <ul><li>可迭代的数据结构会有一个[Symbol.iterator]方法</li> <li>[Symbol.iterator]执行后返回一个iterator对象</li> <li>iterator对象有一个next方法</li> <li>执行一次next方法(消耗一次迭代器)会返回一个有value,done属性的对象</li></ul> <p>es5实现一个迭代器</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token parameter">items</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> done <span class="token operator">=</span> i <span class="token operator">&gt;=</span> item<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token operator">!</span>done <span class="token operator">?</span> items<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token punctuation">{</span>
                done<span class="token operator">:</span> done<span class="token punctuation">,</span>
                value<span class="token operator">:</span> value
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// iterator 就是一个迭代器对象</span>
<span class="token keyword">var</span> iterator <span class="token operator">=</span> <span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { done: false, value: 1 }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { done: false, value: 2 }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { done: false, value: 3 }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { done: true, value: undefined }</span>
</code></pre></div><h2 id="for-of循环"><a href="#for-of循环" class="header-anchor">#</a> for...of循环</h2> <ul><li>for ... of只能用在<strong>可迭代对象</strong>上,获取的是迭代器<strong>返回的value值</strong>,for ... in 可以获取<strong>所有对象的键名</strong></li> <li>for ... in<strong>会遍历对象的整个原型链</strong>,性能非常差不推荐使用,而for ... of<strong>只遍历当前对象</strong>不会遍历它的原型链</li> <li>对于数组的遍历,for ... in会返回数组中所有<strong>可枚举的属性</strong>(包括原型链上可枚举的属性),for ... of只返回数组的下标对应的属性值</li> <li>for... of循环同时支持break,continue,return(在函数中调用的话)并且可以和对象解构赋值一起使用</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> obj<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token operator">:</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">}</span> <span class="token keyword">of</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>a <span class="token comment">//1=&gt;2=&gt;3</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="es6-module"><a href="#es6-module" class="header-anchor">#</a> ES6 Module</h2> <p>ES6 Module使用import关键字导入模块，export关键字导出模块，它还有以下特点</p> <ul><li>ES6 Module是静态的，也就是说它是在编译阶段运行，和var以及function一样具有提升效果（这个特点使得它支持tree shaking）</li> <li>自动采用严格模式（顶层的this返回undefined）</li> <li>ES6 Module支持使用export {&lt;变量&gt;}导出具名的接口，或者export default导出匿名的接口</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//module.js 导出</span>
<span class="token keyword">let</span> x<span class="token operator">=</span><span class="token number">10</span>
<span class="token keyword">let</span> y<span class="token operator">=</span><span class="token number">20</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>x<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> y
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//a.js导入</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>x<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./module.js&quot;</span>
<span class="token keyword">import</span> y <span class="token keyword">from</span> <span class="token string">'./module.js'</span>
</code></pre></div><blockquote><p>export {&lt;变量&gt;}导出的是一个变量的引用，export default导出的是一个值。在a.js中使用import导入这2个变量的后，在module.js中因为某些原因<strong>x变量被改变了，那么会立刻反映到a.js，而module.js中的y变量改变后，a.js中的y还是原来的值</strong></p></blockquote> <p>ES6 Module和CommonJs的一些区别</p> <ul><li>CommonJs输出的是一个值的拷贝,ES6 Module通过export {&lt;变量&gt;}输出的是一个变量的引用,export default输出的是一个值</li> <li>CommonJs运行在服务器上,被设计为运行时加载,即代码执行到那一行才回去加载模块,而ES6 Module是静态的输出一个接口,发生在编译的阶段</li> <li>CommonJs在第一次加载的时候运行一次并且会生成一个缓存,之后加载返回的都是缓存中的内容</li></ul> <p>参考文章：</p> <ol><li><a href="https://juejin.im/post/5c6234f16fb9a049a81fcca5" target="_blank" rel="noopener noreferrer">近一万字的ES6语法知识点补充<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5cef46226fb9a07eaf2b7516#heading-9" target="_blank" rel="noopener noreferrer">一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ol> <h2 id="proxy（重点）"><a href="#proxy（重点）" class="header-anchor">#</a> Proxy（重点）</h2> <p>Proxy作为一个&quot;拦截器&quot;,访问对象,必须先经过这层拦截器,Proxy同样是一个构造函数,使用new关键字生成一个拦截对象的实例。Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有</p> <h2 id="proxy"><a href="#proxy" class="header-anchor">#</a> proxy</h2> <h3 id="术语"><a href="#术语" class="header-anchor">#</a> 术语</h3> <ul><li>handler
包含捕捉器（trap）的占位符对象，可译为处理器对象。一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li> <li>traps
提供属性访问的方法。这类似于操作系统中捕获器的概念。</li> <li>target
被 Proxy 代理虚拟化的对象。它常被作为代理的存储后端。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> prop <span class="token keyword">in</span> obj <span class="token operator">?</span> obj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">37</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>a<span class="token punctuation">,</span> p<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 1, undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'c'</span> <span class="token keyword">in</span> p<span class="token punctuation">,</span> p<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false, 37</span>
</code></pre></div><p>注意：
代理应该在所有地方都完全替代目标对象。目标对象被代理后，任何人都不应该再引用目标对象。否则很容易搞砸。</p> <div class="language-js extra-class"><pre class="language-js"><code>dictionary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="set方法"><a href="#set方法" class="header-anchor">#</a> set方法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">// (*)</span>
  <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截写入属性操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加成功</span>
numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加成功</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Length is: &quot;</span> <span class="token operator">+</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError（proxy 的 'set' 返回 false）</span>
</code></pre></div><blockquote><ul><li>数组的内建方法依然有效！值被使用 push 方法添加到数组。当值被添加到数组后，数组的 length 属性会自动增加。我们的代理对象 proxy 不会破坏任何东西。我们不必重写诸如 push 和 unshift 等添加元素的数组方法。</li> <li>对于 set 操作，它必须在成功写入时返回 true。如果我们忘记这样做，或返回任何假（falsy）值，则该操作将触发 TypeError。</li></ul></blockquote> <p>参考文章：</p> <ol><li><a href="https://juejin.im/post/5efd6683e51d453475009ea6" target="_blank" rel="noopener noreferrer">JavaScript ES6代理的实际用例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy  MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5d2e657ae51d4510b71da69d" target="_blank" rel="noopener noreferrer">Proxy 的巧用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://zh.javascript.info/proxy#tasks" target="_blank" rel="noopener noreferrer">Proxy 和 Reflect（分析较深入）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ol> <h2 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h2> <p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。Reflect与Proxy是相辅相成的，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</p> <p>检测一个对象是否存在特定属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> duck <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'Maurice'</span><span class="token punctuation">,</span>
  color<span class="token operator">:</span> <span class="token string">'white'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">greeting</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Quaaaack! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>duck<span class="token punctuation">,</span> <span class="token string">'color'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// true</span>
Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>duck<span class="token punctuation">,</span> <span class="token string">'haircut'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// false</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'song'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//Reflect保证原生行为能够正常执行</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//通过in操作符会调用has方法</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//reflect 将原有的命令式都转化为函数行为</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span> <span class="token keyword">in</span> proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>不用reflect的写法</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// //通过in操作符会调用has方法</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'_'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> name <span class="token keyword">in</span> target<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><h3 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h3> <p>与Proxy相同，也是ES6新增。
它新增了一些方法，这些方法可以使一些操作更加规范化，更加便利。对象有如下特点:</p> <ol><li>只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在。这些方法能够执行默认行为，无论Proxy怎么修改默认行为，总是可以通过Reflect对应的方法获取默认行为。</li> <li>新增的方法与现有一些方法功能重复，新增的方法会取代现有的方法，比如Reflect.getPrototypeOf()，Object对象具有同样的方法，功能也相同，但是将getPrototypeOf()方法移植到Reflect更加合理。还有一些新增方法用来取代现有的命令式操作，比如判断属性是否存在的in命令，用Reflect.has()方法替代。</li></ol> <h3 id="使用reflect比handler更好的示例"><a href="#使用reflect比handler更好的示例" class="header-anchor">#</a> 使用reflect比handler更好的示例</h3> <p>对于每个可被 Proxy 捕获的内部方法，在 Reflect 中都有一个对应的方法，其名称和参数与 Proxy 陷阱相同。所以，我们可以使用 Reflect 来将操作转发给原始对象。</p> <p>对user 对象进行代理（proxy），没有任何问题。
另一个对象 admin 从 user 继承后，我们可以观察到错误的行为</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  _name<span class="token operator">:</span> <span class="token string">&quot;Guest&quot;</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// (*) target = user（问题关键）</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> admin <span class="token operator">=</span> <span class="token punctuation">{</span>
  __proto__<span class="token operator">:</span> userProxy<span class="token punctuation">,</span><span class="token comment">//继承了user的代理</span>
  _name<span class="token operator">:</span> <span class="token string">&quot;Admin&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 期望输出：Admin</span>
<span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Guest </span>
</code></pre></div><p>问题分析：</p> <ul><li>当我们读取 admin.name 时，由于 admin 对象自身没有对应的的属性，搜索将转到其原型。</li> <li>原型是 userProxy</li> <li>当调用 target[prop] 时，若 prop 是一个 getter，它将在 this=target 上下文中运行其代码。因此，结果是来自原始对象 target 的 this._name，即来自 user。</li></ul> <p>问题解决：</p> <ul><li>如何把上下文传递给getter？对于一个常规函数，我们可以使用 call/apply，但这是一个getter，它不能“被调用”，只能被访问。</li> <li>Reflect.get 可以做到。如果我们使用它，一切都会正常运行。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// receiver = admin</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (*)重点</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><ul><li>现在 receiver 保留了对正确 this 的引用（即 admin），该引用是在 (*) 行中被通过 Reflect.get 传递给 getter 的。</li> <li>因此，return Reflect... 提供了一个安全的方式，可以轻松地转发操作，并确保我们不会忘记与此相关的任何内容。</li></ul></blockquote> <p>参考链接</p> <ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener noreferrer">Reflect MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.jianshu.com/p/d36b06a8010e" target="_blank" rel="noopener noreferrer">ES6 中的Proxy 和 Reflect 到底是什么鬼？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ol> <h2 id="class"><a href="#class" class="header-anchor">#</a> class</h2> <h2 id="es6转换到es5"><a href="#es6转换到es5" class="header-anchor">#</a> es6转换到es5</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/jsDoc/" class="prev router-link-active">
        jsBridge原理 ✅
      </a></span> <span class="next"><a href="/jsDoc/promise.html">
        promise
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.df490d21.js" defer></script><script src="/assets/js/2.9235f093.js" defer></script><script src="/assets/js/8.d3b85309.js" defer></script>
  </body>
</html>
